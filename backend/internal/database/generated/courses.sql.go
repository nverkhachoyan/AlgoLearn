// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: courses.sql

package gen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createCourse = `-- name: CreateCourse :one
INSERT INTO courses (
    name,
    description,
    requirements,
    what_you_learn,
    background_color,
    duration,
    difficulty_level,
    rating,
    folder_object_key,
    img_key,
    media_ext
)
VALUES (
    COALESCE($1::text, ''),
    COALESCE($2::text, ''),
    COALESCE($3::text, ''),
    COALESCE($4::text, ''),
    COALESCE($5::text, ''),
    COALESCE($6::int, 0),
    COALESCE($7::difficulty_level, 'beginner'),
    COALESCE($8::float, 0.0),
    COALESCE($9::UUID, NULL),
    COALESCE($10::UUID, NULL),
    COALESCE($11::text, '')
)
RETURNING id
`

type CreateCourseParams struct {
	Name            string          `json:"name"`
	Description     string          `json:"description"`
	Requirements    string          `json:"requirements"`
	WhatYouLearn    string          `json:"whatYouLearn"`
	BackgroundColor string          `json:"backgroundColor"`
	Duration        int32           `json:"duration"`
	DifficultyLevel DifficultyLevel `json:"difficultyLevel"`
	Rating          float64         `json:"rating"`
	FolderObjectKey uuid.UUID       `json:"folderObjectKey"`
	ImgKey          uuid.UUID       `json:"imgKey"`
	MediaExt        string          `json:"mediaExt"`
}

func (q *Queries) CreateCourse(ctx context.Context, arg CreateCourseParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createCourse,
		arg.Name,
		arg.Description,
		arg.Requirements,
		arg.WhatYouLearn,
		arg.BackgroundColor,
		arg.Duration,
		arg.DifficultyLevel,
		arg.Rating,
		arg.FolderObjectKey,
		arg.ImgKey,
		arg.MediaExt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createCourseTag = `-- name: CreateCourseTag :one
INSERT INTO tags (name)
VALUES ($1::text)
ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
RETURNING id
`

func (q *Queries) CreateCourseTag(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRowContext(ctx, createCourseTag, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteCourse = `-- name: DeleteCourse :exec
DELETE FROM courses WHERE id = $1::int
`

func (q *Queries) DeleteCourse(ctx context.Context, courseID int32) error {
	_, err := q.db.ExecContext(ctx, deleteCourse, courseID)
	return err
}

const deleteModuleProgress = `-- name: DeleteModuleProgress :exec
WITH
    course_modules AS (
        SELECT m.id as module_id
        FROM modules m
            JOIN units u ON u.id = m.unit_id
        WHERE
            u.course_id = $2::int
    )
DELETE FROM user_module_progress
WHERE
    module_id IN (
        SELECT module_id
        FROM course_modules
    )
    AND (
        $1::int = 0
        OR user_id = $1::int
    )
`

type DeleteModuleProgressParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

func (q *Queries) DeleteModuleProgress(ctx context.Context, arg DeleteModuleProgressParams) error {
	_, err := q.db.ExecContext(ctx, deleteModuleProgress, arg.UserID, arg.CourseID)
	return err
}

const deleteSectionProgress = `-- name: DeleteSectionProgress :exec
WITH
    course_modules AS (
        SELECT m.id as module_id
        FROM modules m
            JOIN units u ON u.id = m.unit_id
        WHERE
            u.course_id = $2::int
    )
DELETE FROM user_section_progress
WHERE
    section_id IN (
        SELECT s.id
        FROM sections s
        WHERE
            s.module_id IN (
                SELECT module_id
                FROM course_modules
            )
    )
    AND (
        $1::int = 0
        OR user_id = $1::int
    )
`

type DeleteSectionProgressParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

func (q *Queries) DeleteSectionProgress(ctx context.Context, arg DeleteSectionProgressParams) error {
	_, err := q.db.ExecContext(ctx, deleteSectionProgress, arg.UserID, arg.CourseID)
	return err
}

const deleteUserCourse = `-- name: DeleteUserCourse :exec
DELETE FROM user_courses
WHERE user_id = $1::int
AND course_id = $2::int
`

type DeleteUserCourseParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

func (q *Queries) DeleteUserCourse(ctx context.Context, arg DeleteUserCourseParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserCourse, arg.UserID, arg.CourseID)
	return err
}

const getAllCoursesWithOptionalProgress = `-- name: GetAllCoursesWithOptionalProgress :many
WITH user_progress AS (
    SELECT
        uc.course_id,
        u.id as unit_id,
        u.created_at as unit_created_at,
        u.updated_at as unit_updated_at,
        u.unit_number,
        u.name as unit_name,
        u.description as unit_description,
        u.folder_object_key as unit_folder_object_key,
        u.img_key as unit_img_key,
        u.media_ext as unit_media_ext,
        m.id as module_id,
        ump.created_at as module_created_at,
        ump.updated_at as module_updated_at,
        m.module_number,
        m.name as module_name,
        m.description as module_description,
        m.folder_object_key as module_folder_object_key,
        m.img_key as module_img_key,
        m.media_ext as module_media_ext,
        ump.progress as module_progress,
        ump.status as module_status
    FROM user_courses uc
             JOIN units u ON u.course_id = uc.course_id
             JOIN modules m ON m.unit_id = u.id
             LEFT JOIN user_module_progress ump ON ump.module_id = m.id
        AND ump.user_id = $5::int
    WHERE uc.user_id = $5::int
    ORDER BY ump.updated_at DESC NULLS LAST
)
SELECT
    c.id,
    c.created_at,
    c.updated_at,
    c.name,
    c.description,
    c.requirements,
    c.what_you_learn,
    c.background_color,
    c.folder_object_key,
    c.img_key,
    c.media_ext,
    c.duration,
    c.difficulty_level,
    c.rating,
    up.unit_id as current_unit_id,
    up.unit_created_at,
    up.unit_updated_at,
    up.unit_number,
    up.unit_name,
    up.unit_description,
    up.module_id as current_module_id,
    up.module_created_at,
    up.module_updated_at,
    up.module_number,
    up.module_id as module_unit_id,
    up.module_name,
    up.module_description,
    COALESCE(up.module_progress, 0) as module_progress,
    COALESCE(up.module_status, 'uninitiated') as module_status,
   (SELECT COUNT(*) FROM courses) as total_count
FROM (
    SELECT id
    FROM courses
    ORDER BY id
    LIMIT $2::int
    OFFSET $1::int
) paginated_courses
JOIN courses c ON c.id = paginated_courses.id
         LEFT JOIN user_progress up ON up.course_id = c.id
ORDER BY
    CASE WHEN $3::text = 'id' AND LOWER($4::text) = 'desc' THEN c.id END DESC,
    CASE WHEN $3::text = 'id' AND LOWER($4::text) = 'asc' THEN c.id END ASC,
    CASE WHEN $3::text = 'created_at' AND LOWER($4::text) = 'desc' THEN c.created_at END DESC,
    CASE WHEN $3::text = 'created_at' AND LOWER($4::text) = 'asc' THEN c.created_at END ASC,
    CASE WHEN $3::text = 'updated_at' AND LOWER($4::text) = 'desc' THEN c.updated_at END DESC,
    CASE WHEN $3::text = 'updated_at' AND LOWER($4::text) = 'asc' THEN c.updated_at END ASC,
    CASE WHEN $3::text = 'name' AND LOWER($4::text) = 'desc' THEN c.name END DESC,
    CASE WHEN $3::text = 'name' AND LOWER($4::text) = 'asc' THEN c.name END ASC,
    CASE WHEN $3::text = 'description' AND LOWER($4::text) = 'desc' THEN c.description END DESC,
    CASE WHEN $3::text = 'description' AND LOWER($4::text) = 'asc' THEN c.description END ASC,
    CASE WHEN $3::text = 'rating' AND LOWER($4::text) = 'desc' THEN c.rating END DESC,
    CASE WHEN $3::text = 'rating' AND LOWER($4::text) = 'asc' THEN c.rating END ASC,
    CASE WHEN $3::text = 'duration' AND LOWER($4::text) = 'desc' THEN c.duration END DESC,
    CASE WHEN $3::text = 'duration' AND LOWER($4::text) = 'asc' THEN c.duration END ASC,
    CASE WHEN $3::text = 'difficulty_level' AND LOWER($4::text) = 'desc' THEN c.difficulty_level END DESC,
    CASE WHEN $3::text = 'difficulty_level' AND LOWER($4::text) = 'asc' THEN c.difficulty_level END ASC,
    CASE WHEN $3::text = 'draft' AND LOWER($4::text) = 'desc' THEN c.draft END DESC,
    CASE WHEN $3::text = 'draft' AND LOWER($4::text) = 'asc' THEN c.draft END ASC,
    CASE WHEN $3::text = 'user_progress' AND LOWER($4::text) = 'desc' THEN up.course_id END DESC,
    CASE WHEN $3::text = 'user_progress' AND LOWER($4::text) = 'asc' THEN up.course_id END ASC,
    CASE WHEN up.module_updated_at IS NOT NULL THEN up.module_updated_at ELSE c.created_at END DESC NULLS LAST
`

type GetAllCoursesWithOptionalProgressParams struct {
	PageOffset    int32          `json:"pageOffset"`
	PageLimit     int32          `json:"pageLimit"`
	SortColumn    sql.NullString `json:"sortColumn"`
	SortDirection sql.NullString `json:"sortDirection"`
	UserID        int32          `json:"userId"`
}

type GetAllCoursesWithOptionalProgressRow struct {
	ID                int32                `json:"id"`
	CreatedAt         time.Time            `json:"createdAt"`
	UpdatedAt         time.Time            `json:"updatedAt"`
	Name              string               `json:"name"`
	Description       string               `json:"description"`
	Requirements      sql.NullString       `json:"requirements"`
	WhatYouLearn      sql.NullString       `json:"whatYouLearn"`
	BackgroundColor   sql.NullString       `json:"backgroundColor"`
	FolderObjectKey   uuid.NullUUID        `json:"folderObjectKey"`
	ImgKey            uuid.NullUUID        `json:"imgKey"`
	MediaExt          sql.NullString       `json:"mediaExt"`
	Duration          sql.NullInt32        `json:"duration"`
	DifficultyLevel   NullDifficultyLevel  `json:"difficultyLevel"`
	Rating            sql.NullFloat64      `json:"rating"`
	CurrentUnitID     sql.NullInt32        `json:"currentUnitId"`
	UnitCreatedAt     sql.NullTime         `json:"unitCreatedAt"`
	UnitUpdatedAt     sql.NullTime         `json:"unitUpdatedAt"`
	UnitNumber        sql.NullInt32        `json:"unitNumber"`
	UnitName          sql.NullString       `json:"unitName"`
	UnitDescription   sql.NullString       `json:"unitDescription"`
	CurrentModuleID   sql.NullInt32        `json:"currentModuleId"`
	ModuleCreatedAt   sql.NullTime         `json:"moduleCreatedAt"`
	ModuleUpdatedAt   sql.NullTime         `json:"moduleUpdatedAt"`
	ModuleNumber      sql.NullInt32        `json:"moduleNumber"`
	ModuleUnitID      sql.NullInt32        `json:"moduleUnitId"`
	ModuleName        sql.NullString       `json:"moduleName"`
	ModuleDescription sql.NullString       `json:"moduleDescription"`
	ModuleProgress    float64              `json:"moduleProgress"`
	ModuleStatus      ModuleProgressStatus `json:"moduleStatus"`
	TotalCount        int64                `json:"totalCount"`
}

func (q *Queries) GetAllCoursesWithOptionalProgress(ctx context.Context, arg GetAllCoursesWithOptionalProgressParams) ([]GetAllCoursesWithOptionalProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCoursesWithOptionalProgress,
		arg.PageOffset,
		arg.PageLimit,
		arg.SortColumn,
		arg.SortDirection,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCoursesWithOptionalProgressRow{}
	for rows.Next() {
		var i GetAllCoursesWithOptionalProgressRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Requirements,
			&i.WhatYouLearn,
			&i.BackgroundColor,
			&i.FolderObjectKey,
			&i.ImgKey,
			&i.MediaExt,
			&i.Duration,
			&i.DifficultyLevel,
			&i.Rating,
			&i.CurrentUnitID,
			&i.UnitCreatedAt,
			&i.UnitUpdatedAt,
			&i.UnitNumber,
			&i.UnitName,
			&i.UnitDescription,
			&i.CurrentModuleID,
			&i.ModuleCreatedAt,
			&i.ModuleUpdatedAt,
			&i.ModuleNumber,
			&i.ModuleUnitID,
			&i.ModuleName,
			&i.ModuleDescription,
			&i.ModuleProgress,
			&i.ModuleStatus,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCodeSection = `-- name: GetCodeSection :one
SELECT 
    code,
    language,
    object_key as object_key,
    media_ext as media_ext
FROM code_sections
WHERE section_id = $1::int
`

type GetCodeSectionRow struct {
	Code      string         `json:"code"`
	Language  sql.NullString `json:"language"`
	ObjectKey uuid.NullUUID  `json:"objectKey"`
	MediaExt  sql.NullString `json:"mediaExt"`
}

func (q *Queries) GetCodeSection(ctx context.Context, sectionID int32) (GetCodeSectionRow, error) {
	row := q.db.QueryRowContext(ctx, getCodeSection, sectionID)
	var i GetCodeSectionRow
	err := row.Scan(
		&i.Code,
		&i.Language,
		&i.ObjectKey,
		&i.MediaExt,
	)
	return i, err
}

const getCourseAuthors = `-- name: GetCourseAuthors :many
SELECT u.id, u.first_name, u.last_name
FROM users u
    JOIN course_authors ca ON ca.user_id = u.id
WHERE
    ca.course_id = $1::int
`

type GetCourseAuthorsRow struct {
	ID        int32          `json:"id"`
	FirstName sql.NullString `json:"firstName"`
	LastName  sql.NullString `json:"lastName"`
}

func (q *Queries) GetCourseAuthors(ctx context.Context, courseID int32) ([]GetCourseAuthorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCourseAuthors, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCourseAuthorsRow{}
	for rows.Next() {
		var i GetCourseAuthorsRow
		if err := rows.Scan(&i.ID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseByID = `-- name: GetCourseByID :one
SELECT
    id,
    created_at,
    updated_at,
    folder_object_key,
    img_key,
    media_ext,
    name,
    description,
    requirements,
    what_you_learn,
    background_color,
    duration,
    difficulty_level,
    rating
FROM courses
WHERE
    id = $1::int
`

type GetCourseByIDRow struct {
	ID              int32               `json:"id"`
	CreatedAt       time.Time           `json:"createdAt"`
	UpdatedAt       time.Time           `json:"updatedAt"`
	FolderObjectKey uuid.NullUUID       `json:"folderObjectKey"`
	ImgKey          uuid.NullUUID       `json:"imgKey"`
	MediaExt        sql.NullString      `json:"mediaExt"`
	Name            string              `json:"name"`
	Description     string              `json:"description"`
	Requirements    sql.NullString      `json:"requirements"`
	WhatYouLearn    sql.NullString      `json:"whatYouLearn"`
	BackgroundColor sql.NullString      `json:"backgroundColor"`
	Duration        sql.NullInt32       `json:"duration"`
	DifficultyLevel NullDifficultyLevel `json:"difficultyLevel"`
	Rating          sql.NullFloat64     `json:"rating"`
}

func (q *Queries) GetCourseByID(ctx context.Context, courseID int32) (GetCourseByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCourseByID, courseID)
	var i GetCourseByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FolderObjectKey,
		&i.ImgKey,
		&i.MediaExt,
		&i.Name,
		&i.Description,
		&i.Requirements,
		&i.WhatYouLearn,
		&i.BackgroundColor,
		&i.Duration,
		&i.DifficultyLevel,
		&i.Rating,
	)
	return i, err
}

const getCourseProgressSummaryBase = `-- name: GetCourseProgressSummaryBase :one
WITH current_unit_id AS (
    SELECT u.id
    FROM units u
    WHERE u.course_id = $2::int
    ORDER BY u.updated_at DESC
    LIMIT 1
),
current_module_id AS (
    SELECT m.id
    FROM modules m
    WHERE m.unit_id = (SELECT id FROM current_unit_id)
    ORDER BY m.updated_at DESC
    LIMIT 1
)
SELECT
    c.id,
    c.folder_object_key,
    c.created_at,
    c.updated_at,
    c.name,
    c.description,
    c.requirements,
    c.what_you_learn,
    c.background_color,
    c.img_key,
    c.media_ext,
    c.difficulty_level,
    c.duration,
    c.rating,
    u.id as unit_id,
    u.folder_object_key as unit_folder_object_key,
    u.img_key as unit_img_key,
    u.media_ext as unit_media_ext,
    u.created_at as unit_created_at,
    u.updated_at as unit_updated_at,
    u.unit_number,
    u.name as unit_name,
    u.description as unit_description,
    m.id as module_id,
    m.folder_object_key as module_folder_object_key,
    m.img_key as module_img_key,
    m.media_ext as module_media_ext,
    m.created_at as module_created_at,
    m.updated_at as module_updated_at,
    m.module_number,
    m.name as module_name,
    m.description as module_description,
    ump.progress as module_progress,
    ump.status as module_status
FROM courses c
         LEFT JOIN current_unit_id cui ON 1=1
         LEFT JOIN current_module_id cmi ON 1=1
         LEFT JOIN units u ON u.id = cui.id
         LEFT JOIN modules m ON m.id = cmi.id
         LEFT JOIN user_courses uc ON uc.course_id = c.id AND uc.user_id = $1::int
         LEFT JOIN user_module_progress ump ON ump.module_id = cmi.id AND ump.user_id = $1::int
WHERE c.id = $2::int
`

type GetCourseProgressSummaryBaseParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

type GetCourseProgressSummaryBaseRow struct {
	ID                    int32                    `json:"id"`
	FolderObjectKey       uuid.NullUUID            `json:"folderObjectKey"`
	CreatedAt             time.Time                `json:"createdAt"`
	UpdatedAt             time.Time                `json:"updatedAt"`
	Name                  string                   `json:"name"`
	Description           string                   `json:"description"`
	Requirements          sql.NullString           `json:"requirements"`
	WhatYouLearn          sql.NullString           `json:"whatYouLearn"`
	BackgroundColor       sql.NullString           `json:"backgroundColor"`
	ImgKey                uuid.NullUUID            `json:"imgKey"`
	MediaExt              sql.NullString           `json:"mediaExt"`
	DifficultyLevel       NullDifficultyLevel      `json:"difficultyLevel"`
	Duration              sql.NullInt32            `json:"duration"`
	Rating                sql.NullFloat64          `json:"rating"`
	UnitID                sql.NullInt32            `json:"unitId"`
	UnitFolderObjectKey   uuid.NullUUID            `json:"unitFolderObjectKey"`
	UnitImgKey            uuid.NullUUID            `json:"unitImgKey"`
	UnitMediaExt          sql.NullString           `json:"unitMediaExt"`
	UnitCreatedAt         sql.NullTime             `json:"unitCreatedAt"`
	UnitUpdatedAt         sql.NullTime             `json:"unitUpdatedAt"`
	UnitNumber            sql.NullInt32            `json:"unitNumber"`
	UnitName              sql.NullString           `json:"unitName"`
	UnitDescription       sql.NullString           `json:"unitDescription"`
	ModuleID              sql.NullInt32            `json:"moduleId"`
	ModuleFolderObjectKey uuid.NullUUID            `json:"moduleFolderObjectKey"`
	ModuleImgKey          uuid.NullUUID            `json:"moduleImgKey"`
	ModuleMediaExt        sql.NullString           `json:"moduleMediaExt"`
	ModuleCreatedAt       sql.NullTime             `json:"moduleCreatedAt"`
	ModuleUpdatedAt       sql.NullTime             `json:"moduleUpdatedAt"`
	ModuleNumber          sql.NullInt32            `json:"moduleNumber"`
	ModuleName            sql.NullString           `json:"moduleName"`
	ModuleDescription     sql.NullString           `json:"moduleDescription"`
	ModuleProgress        sql.NullFloat64          `json:"moduleProgress"`
	ModuleStatus          NullModuleProgressStatus `json:"moduleStatus"`
}

func (q *Queries) GetCourseProgressSummaryBase(ctx context.Context, arg GetCourseProgressSummaryBaseParams) (GetCourseProgressSummaryBaseRow, error) {
	row := q.db.QueryRowContext(ctx, getCourseProgressSummaryBase, arg.UserID, arg.CourseID)
	var i GetCourseProgressSummaryBaseRow
	err := row.Scan(
		&i.ID,
		&i.FolderObjectKey,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Requirements,
		&i.WhatYouLearn,
		&i.BackgroundColor,
		&i.ImgKey,
		&i.MediaExt,
		&i.DifficultyLevel,
		&i.Duration,
		&i.Rating,
		&i.UnitID,
		&i.UnitFolderObjectKey,
		&i.UnitImgKey,
		&i.UnitMediaExt,
		&i.UnitCreatedAt,
		&i.UnitUpdatedAt,
		&i.UnitNumber,
		&i.UnitName,
		&i.UnitDescription,
		&i.ModuleID,
		&i.ModuleFolderObjectKey,
		&i.ModuleImgKey,
		&i.ModuleMediaExt,
		&i.ModuleCreatedAt,
		&i.ModuleUpdatedAt,
		&i.ModuleNumber,
		&i.ModuleName,
		&i.ModuleDescription,
		&i.ModuleProgress,
		&i.ModuleStatus,
	)
	return i, err
}

const getCourseTags = `-- name: GetCourseTags :many
SELECT t.id, t.name
FROM tags t
    JOIN course_tags ct ON ct.tag_id = t.id
WHERE
    ct.course_id = $1::int
`

func (q *Queries) GetCourseTags(ctx context.Context, courseID int32) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getCourseTags, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseUnits = `-- name: GetCourseUnits :many
SELECT
    id,
    folder_object_key,
    img_key,
    media_ext,
    created_at,
    updated_at,
    unit_number,
    course_id,
    name,
    description
FROM units
WHERE
    course_id = $1::int
ORDER BY unit_number
`

type GetCourseUnitsRow struct {
	ID              int32          `json:"id"`
	FolderObjectKey uuid.NullUUID  `json:"folderObjectKey"`
	ImgKey          uuid.NullUUID  `json:"imgKey"`
	MediaExt        sql.NullString `json:"mediaExt"`
	CreatedAt       time.Time      `json:"createdAt"`
	UpdatedAt       time.Time      `json:"updatedAt"`
	UnitNumber      int32          `json:"unitNumber"`
	CourseID        int32          `json:"courseId"`
	Name            string         `json:"name"`
	Description     string         `json:"description"`
}

func (q *Queries) GetCourseUnits(ctx context.Context, courseID int32) ([]GetCourseUnitsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCourseUnits, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCourseUnitsRow{}
	for rows.Next() {
		var i GetCourseUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.FolderObjectKey,
			&i.ImgKey,
			&i.MediaExt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnitNumber,
			&i.CourseID,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesCount = `-- name: GetCoursesCount :one
SELECT COUNT(*) FROM courses
`

func (q *Queries) GetCoursesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCoursesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCurrentUnitAndModule = `-- name: GetCurrentUnitAndModule :one
WITH latest_module_progress AS (
    SELECT 
        ump.module_id,
        ump.updated_at
    FROM user_module_progress ump
    JOIN modules m ON m.id = ump.module_id
    JOIN units u ON u.id = m.unit_id
    WHERE ump.user_id = $1 
    AND u.course_id = $2
    ORDER BY ump.updated_at DESC NULLS LAST
    LIMIT 1
)
SELECT
    u.id as unit_id,
    u.folder_object_key as unit_folder_object_key,
    u.img_key as unit_img_key,
    u.media_ext as unit_media_ext,
    u.created_at as unit_created_at,
    u.updated_at as unit_updated_at,
    u.name as unit_name,
    u.description as unit_description,
    u.unit_number as unit_number,
    m.id as module_id,
    m.folder_object_key as module_folder_object_key,
    m.img_key as module_img_key,
    m.media_ext as module_media_ext,
    m.created_at as module_created_at,
    m.updated_at as module_updated_at,
    m.name as module_name,
    m.description as module_description,
    m.module_number as module_number,
    COALESCE(ump.progress, 0) as module_progress,
    COALESCE(ump.status, 'uninitiated'::module_progress_status) as module_status
FROM latest_module_progress lmp
JOIN modules m ON m.id = lmp.module_id
JOIN units u ON u.id = m.unit_id
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1
`

type GetCurrentUnitAndModuleParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

type GetCurrentUnitAndModuleRow struct {
	UnitID                int32                `json:"unitId"`
	UnitFolderObjectKey   uuid.NullUUID        `json:"unitFolderObjectKey"`
	UnitImgKey            uuid.NullUUID        `json:"unitImgKey"`
	UnitMediaExt          sql.NullString       `json:"unitMediaExt"`
	UnitCreatedAt         time.Time            `json:"unitCreatedAt"`
	UnitUpdatedAt         time.Time            `json:"unitUpdatedAt"`
	UnitName              string               `json:"unitName"`
	UnitDescription       string               `json:"unitDescription"`
	UnitNumber            int32                `json:"unitNumber"`
	ModuleID              int32                `json:"moduleId"`
	ModuleFolderObjectKey uuid.NullUUID        `json:"moduleFolderObjectKey"`
	ModuleImgKey          uuid.NullUUID        `json:"moduleImgKey"`
	ModuleMediaExt        sql.NullString       `json:"moduleMediaExt"`
	ModuleCreatedAt       time.Time            `json:"moduleCreatedAt"`
	ModuleUpdatedAt       time.Time            `json:"moduleUpdatedAt"`
	ModuleName            string               `json:"moduleName"`
	ModuleDescription     string               `json:"moduleDescription"`
	ModuleNumber          int32                `json:"moduleNumber"`
	ModuleProgress        float64              `json:"moduleProgress"`
	ModuleStatus          ModuleProgressStatus `json:"moduleStatus"`
}

func (q *Queries) GetCurrentUnitAndModule(ctx context.Context, arg GetCurrentUnitAndModuleParams) (GetCurrentUnitAndModuleRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentUnitAndModule, arg.UserID, arg.CourseID)
	var i GetCurrentUnitAndModuleRow
	err := row.Scan(
		&i.UnitID,
		&i.UnitFolderObjectKey,
		&i.UnitImgKey,
		&i.UnitMediaExt,
		&i.UnitCreatedAt,
		&i.UnitUpdatedAt,
		&i.UnitName,
		&i.UnitDescription,
		&i.UnitNumber,
		&i.ModuleID,
		&i.ModuleFolderObjectKey,
		&i.ModuleImgKey,
		&i.ModuleMediaExt,
		&i.ModuleCreatedAt,
		&i.ModuleUpdatedAt,
		&i.ModuleName,
		&i.ModuleDescription,
		&i.ModuleNumber,
		&i.ModuleProgress,
		&i.ModuleStatus,
	)
	return i, err
}

const getEnrolledCoursesWithProgress = `-- name: GetEnrolledCoursesWithProgress :many
WITH enrolled_count AS (
    SELECT COUNT(*) as total
    FROM courses c
    JOIN user_courses uc ON uc.course_id = c.id AND uc.user_id = $1::int
),
latest_progress AS (
    SELECT
        u.course_id,
        u.id as unit_id,
        u.created_at as unit_created_at,
        u.updated_at as unit_updated_at,
        u.unit_number,
        u.name as unit_name,
        u.description as unit_description,
        u.folder_object_key as unit_folder_object_key,
        u.img_key as unit_img_key,
        u.media_ext as unit_media_ext,
        m.id as module_id,
        m.created_at as module_created_at,
        m.updated_at as module_updated_at,
        m.module_number,
        m.name as module_name,
        m.description as module_description,
        m.folder_object_key as module_folder_object_key,
        m.img_key as module_img_key,
        m.media_ext as module_media_ext,
        ump.progress as module_progress,
        ump.status as module_status
    FROM units u
    JOIN modules m ON m.unit_id = u.id
    JOIN user_module_progress ump ON ump.module_id = m.id
        AND ump.user_id = $1::int
        AND (ump.status = 'uninitiated' OR ump.status = 'in_progress')
    ORDER BY ump.updated_at DESC NULLS LAST
),
enrolled_courses AS (
    SELECT 
        c.id, c.folder_object_key, c.created_at, c.updated_at, c.draft, c.name, c.description, c.img_key, c.media_ext, c.requirements, c.what_you_learn, c.background_color, c.duration, c.difficulty_level, c.rating,
        uc.progress as course_progress,
        (SELECT total FROM enrolled_count) as total_count,
        lp.unit_id,
        lp.unit_created_at,
        lp.unit_updated_at,
        lp.unit_number,
        lp.unit_name,
        lp.unit_description,
        lp.unit_folder_object_key,
        lp.unit_img_key,
        lp.unit_media_ext,
        lp.module_id,
        lp.module_created_at,
        lp.module_updated_at,
        lp.module_number,
        lp.module_name,
        lp.module_description,
        lp.module_folder_object_key,
        lp.module_img_key,
        lp.module_media_ext,
        lp.module_progress,
        lp.module_status
    FROM courses c
    JOIN user_courses uc ON uc.course_id = c.id 
        AND uc.user_id = $1::int
    LEFT JOIN latest_progress lp ON lp.course_id = c.id
    ORDER BY c.created_at DESC
    LIMIT $3::int
    OFFSET $2::int
)
SELECT
    c.id,
    c.folder_object_key,
    c.created_at,
    c.updated_at,
    c.name,
    c.description,
    c.requirements,
    c.what_you_learn,
    c.background_color,
    c.img_key,
    c.media_ext,
    c.duration,
    c.difficulty_level,
    c.rating,
    COALESCE(c.unit_id, 0) as current_unit_id,
    COALESCE(c.unit_created_at, NOW()) as unit_created_at,
    COALESCE(c.unit_updated_at, NOW()) as unit_updated_at,
    COALESCE(c.unit_number, 0) as unit_number,
    COALESCE(c.unit_name, '') as unit_name,
    COALESCE(c.unit_description, '') as unit_description,
    COALESCE(c.unit_folder_object_key, '') as unit_folder_object_key,
    COALESCE(c.unit_img_key, '') as unit_img_key,
    COALESCE(c.unit_media_ext, '') as unit_media_ext,
    COALESCE(c.module_id, 0) as current_module_id,
    COALESCE(c.module_created_at, NOW()) as module_created_at,
    COALESCE(c.module_updated_at, NOW()) as module_updated_at,
    COALESCE(c.module_number, 0) as module_number,
    COALESCE(c.unit_id, 0) as module_unit_id,
    COALESCE(c.module_name, '') as module_name,
    COALESCE(c.module_description, '') as module_description,
    COALESCE(c.module_progress, 0) as module_progress,
    COALESCE(c.module_status, 'uninitiated') as module_status,
    COALESCE(c.module_folder_object_key, '') as module_folder_object_key,
    COALESCE(c.module_img_key, '') as module_img_key,
    COALESCE(c.module_media_ext, '') as module_media_ext,
    c.course_progress,
    c.total_count
FROM enrolled_courses c
`

type GetEnrolledCoursesWithProgressParams struct {
	UserID     int32 `json:"userId"`
	PageOffset int32 `json:"pageOffset"`
	PageLimit  int32 `json:"pageLimit"`
}

type GetEnrolledCoursesWithProgressRow struct {
	ID                    int32                `json:"id"`
	FolderObjectKey       uuid.NullUUID        `json:"folderObjectKey"`
	CreatedAt             time.Time            `json:"createdAt"`
	UpdatedAt             time.Time            `json:"updatedAt"`
	Name                  string               `json:"name"`
	Description           string               `json:"description"`
	Requirements          sql.NullString       `json:"requirements"`
	WhatYouLearn          sql.NullString       `json:"whatYouLearn"`
	BackgroundColor       sql.NullString       `json:"backgroundColor"`
	ImgKey                uuid.NullUUID        `json:"imgKey"`
	MediaExt              sql.NullString       `json:"mediaExt"`
	Duration              sql.NullInt32        `json:"duration"`
	DifficultyLevel       NullDifficultyLevel  `json:"difficultyLevel"`
	Rating                sql.NullFloat64      `json:"rating"`
	CurrentUnitID         int32                `json:"currentUnitId"`
	UnitCreatedAt         sql.NullTime         `json:"unitCreatedAt"`
	UnitUpdatedAt         sql.NullTime         `json:"unitUpdatedAt"`
	UnitNumber            int32                `json:"unitNumber"`
	UnitName              string               `json:"unitName"`
	UnitDescription       string               `json:"unitDescription"`
	UnitFolderObjectKey   uuid.UUID            `json:"unitFolderObjectKey"`
	UnitImgKey            uuid.UUID            `json:"unitImgKey"`
	UnitMediaExt          string               `json:"unitMediaExt"`
	CurrentModuleID       int32                `json:"currentModuleId"`
	ModuleCreatedAt       sql.NullTime         `json:"moduleCreatedAt"`
	ModuleUpdatedAt       sql.NullTime         `json:"moduleUpdatedAt"`
	ModuleNumber          int32                `json:"moduleNumber"`
	ModuleUnitID          int32                `json:"moduleUnitId"`
	ModuleName            string               `json:"moduleName"`
	ModuleDescription     string               `json:"moduleDescription"`
	ModuleProgress        float64              `json:"moduleProgress"`
	ModuleStatus          ModuleProgressStatus `json:"moduleStatus"`
	ModuleFolderObjectKey uuid.UUID            `json:"moduleFolderObjectKey"`
	ModuleImgKey          uuid.UUID            `json:"moduleImgKey"`
	ModuleMediaExt        string               `json:"moduleMediaExt"`
	CourseProgress        float64              `json:"courseProgress"`
	TotalCount            int64                `json:"totalCount"`
}

func (q *Queries) GetEnrolledCoursesWithProgress(ctx context.Context, arg GetEnrolledCoursesWithProgressParams) ([]GetEnrolledCoursesWithProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, getEnrolledCoursesWithProgress, arg.UserID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEnrolledCoursesWithProgressRow{}
	for rows.Next() {
		var i GetEnrolledCoursesWithProgressRow
		if err := rows.Scan(
			&i.ID,
			&i.FolderObjectKey,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Requirements,
			&i.WhatYouLearn,
			&i.BackgroundColor,
			&i.ImgKey,
			&i.MediaExt,
			&i.Duration,
			&i.DifficultyLevel,
			&i.Rating,
			&i.CurrentUnitID,
			&i.UnitCreatedAt,
			&i.UnitUpdatedAt,
			&i.UnitNumber,
			&i.UnitName,
			&i.UnitDescription,
			&i.UnitFolderObjectKey,
			&i.UnitImgKey,
			&i.UnitMediaExt,
			&i.CurrentModuleID,
			&i.ModuleCreatedAt,
			&i.ModuleUpdatedAt,
			&i.ModuleNumber,
			&i.ModuleUnitID,
			&i.ModuleName,
			&i.ModuleDescription,
			&i.ModuleProgress,
			&i.ModuleStatus,
			&i.ModuleFolderObjectKey,
			&i.ModuleImgKey,
			&i.ModuleMediaExt,
			&i.CourseProgress,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstUnitAndModuleInCourse = `-- name: GetFirstUnitAndModuleInCourse :one
SELECT 
    u.id as unit_id,
    m.id as module_id
FROM units u
JOIN modules m ON m.unit_id = u.id
WHERE u.course_id = $1::int
ORDER BY u.unit_number ASC, m.module_number ASC
LIMIT 1
`

type GetFirstUnitAndModuleInCourseRow struct {
	UnitID   int32 `json:"unitId"`
	ModuleID int32 `json:"moduleId"`
}

func (q *Queries) GetFirstUnitAndModuleInCourse(ctx context.Context, courseID int32) (GetFirstUnitAndModuleInCourseRow, error) {
	row := q.db.QueryRowContext(ctx, getFirstUnitAndModuleInCourse, courseID)
	var i GetFirstUnitAndModuleInCourseRow
	err := row.Scan(&i.UnitID, &i.ModuleID)
	return i, err
}

const getImageSection = `-- name: GetImageSection :one
SELECT 
    url,
    headline,
    caption,
    alt_text,
    width,
    height,
    object_key,
    media_ext
FROM image_sections
WHERE section_id = $1::int
`

type GetImageSectionRow struct {
	Url       sql.NullString `json:"url"`
	Headline  sql.NullString `json:"headline"`
	Caption   sql.NullString `json:"caption"`
	AltText   sql.NullString `json:"altText"`
	Width     sql.NullInt32  `json:"width"`
	Height    sql.NullInt32  `json:"height"`
	ObjectKey uuid.NullUUID  `json:"objectKey"`
	MediaExt  sql.NullString `json:"mediaExt"`
}

func (q *Queries) GetImageSection(ctx context.Context, sectionID int32) (GetImageSectionRow, error) {
	row := q.db.QueryRowContext(ctx, getImageSection, sectionID)
	var i GetImageSectionRow
	err := row.Scan(
		&i.Url,
		&i.Headline,
		&i.Caption,
		&i.AltText,
		&i.Width,
		&i.Height,
		&i.ObjectKey,
		&i.MediaExt,
	)
	return i, err
}

const getMarkdownSection = `-- name: GetMarkdownSection :one
SELECT 
    markdown as markdown,
    object_key as object_key,
    media_ext as media_ext
FROM markdown_sections
WHERE section_id = $1::int
`

type GetMarkdownSectionRow struct {
	Markdown  string         `json:"markdown"`
	ObjectKey uuid.NullUUID  `json:"objectKey"`
	MediaExt  sql.NullString `json:"mediaExt"`
}

func (q *Queries) GetMarkdownSection(ctx context.Context, sectionID int32) (GetMarkdownSectionRow, error) {
	row := q.db.QueryRowContext(ctx, getMarkdownSection, sectionID)
	var i GetMarkdownSectionRow
	err := row.Scan(&i.Markdown, &i.ObjectKey, &i.MediaExt)
	return i, err
}

const getModuleProgressByUnit = `-- name: GetModuleProgressByUnit :many
SELECT m.id, m.created_at, m.updated_at, m.module_number, m.unit_id, m.name, m.description, m.folder_object_key, m.img_key, m.media_ext, ump.progress, ump.status
FROM
    modules m
    LEFT JOIN user_module_progress ump ON ump.module_id = m.id
    AND ump.user_id = $1::int
WHERE
    m.unit_id = $2::int
ORDER BY m.module_number
`

type GetModuleProgressByUnitParams struct {
	UserID int32 `json:"userId"`
	UnitID int32 `json:"unitId"`
}

type GetModuleProgressByUnitRow struct {
	ID              int32                    `json:"id"`
	CreatedAt       time.Time                `json:"createdAt"`
	UpdatedAt       time.Time                `json:"updatedAt"`
	ModuleNumber    int32                    `json:"moduleNumber"`
	UnitID          int32                    `json:"unitId"`
	Name            string                   `json:"name"`
	Description     string                   `json:"description"`
	FolderObjectKey uuid.NullUUID            `json:"folderObjectKey"`
	ImgKey          uuid.NullUUID            `json:"imgKey"`
	MediaExt        sql.NullString           `json:"mediaExt"`
	Progress        sql.NullFloat64          `json:"progress"`
	Status          NullModuleProgressStatus `json:"status"`
}

func (q *Queries) GetModuleProgressByUnit(ctx context.Context, arg GetModuleProgressByUnitParams) ([]GetModuleProgressByUnitRow, error) {
	rows, err := q.db.QueryContext(ctx, getModuleProgressByUnit, arg.UserID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModuleProgressByUnitRow{}
	for rows.Next() {
		var i GetModuleProgressByUnitRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ModuleNumber,
			&i.UnitID,
			&i.Name,
			&i.Description,
			&i.FolderObjectKey,
			&i.ImgKey,
			&i.MediaExt,
			&i.Progress,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModuleSectionsWithProgress = `-- name: GetModuleSectionsWithProgress :many
SELECT 
    s.id, 
    s.created_at, 
    s.updated_at, 
    s.type, 
    s.position, 
    s.module_id, 
    usp.seen_at, 
    usp.started_at, 
    usp.completed_at, 
    usp.has_seen
FROM
    sections s
    LEFT JOIN user_section_progress usp ON usp.section_id = s.id
    AND usp.user_id = $1::int
WHERE
    s.module_id = $2::int
ORDER BY s.position
`

type GetModuleSectionsWithProgressParams struct {
	UserID   int32 `json:"userId"`
	ModuleID int32 `json:"moduleId"`
}

type GetModuleSectionsWithProgressRow struct {
	ID          int32        `json:"id"`
	CreatedAt   time.Time    `json:"createdAt"`
	UpdatedAt   time.Time    `json:"updatedAt"`
	Type        SectionType  `json:"type"`
	Position    int32        `json:"position"`
	ModuleID    int32        `json:"moduleId"`
	SeenAt      sql.NullTime `json:"seenAt"`
	StartedAt   sql.NullTime `json:"startedAt"`
	CompletedAt sql.NullTime `json:"completedAt"`
	HasSeen     sql.NullBool `json:"hasSeen"`
}

func (q *Queries) GetModuleSectionsWithProgress(ctx context.Context, arg GetModuleSectionsWithProgressParams) ([]GetModuleSectionsWithProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, getModuleSectionsWithProgress, arg.UserID, arg.ModuleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModuleSectionsWithProgressRow{}
	for rows.Next() {
		var i GetModuleSectionsWithProgressRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Position,
			&i.ModuleID,
			&i.SeenAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.HasSeen,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionSection = `-- name: GetQuestionSection :one

SELECT 
    q.id,
    q.question,
    q.type,
    object_key as object_key,
    media_ext as media_ext,
    COALESCE(
        json_agg(
            json_build_object(
                'id', qo.id,
                'content', qo.content,
                'is_correct', qo.is_correct
            ) ORDER BY qo.id
        ),
        '[]'::json
    ) as question_options
FROM question_sections qs
JOIN questions q ON q.id = qs.question_id
LEFT JOIN question_options qo ON qo.question_id = q.id
WHERE qs.section_id = $1::int
GROUP BY q.id, q.question, q.type
`

type GetQuestionSectionRow struct {
	ID              int32          `json:"id"`
	Question        string         `json:"question"`
	Type            string         `json:"type"`
	ObjectKey       uuid.NullUUID  `json:"objectKey"`
	MediaExt        sql.NullString `json:"mediaExt"`
	QuestionOptions interface{}    `json:"questionOptions"`
}

// object_key UUID,
//
//	width INTEGER DEFAULT 200,
//	height INTEGER DEFAULT 200,
//	media_ext VARCHAR(10),
//	url TEXT,
//	headline TEXT NOT NULL,
//	caption TEXT NOT NULL,
func (q *Queries) GetQuestionSection(ctx context.Context, sectionID int32) (GetQuestionSectionRow, error) {
	row := q.db.QueryRowContext(ctx, getQuestionSection, sectionID)
	var i GetQuestionSectionRow
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.Type,
		&i.ObjectKey,
		&i.MediaExt,
		&i.QuestionOptions,
	)
	return i, err
}

const getSectionContent = `-- name: GetSectionContent :one
SELECT 
    CASE s.type
        WHEN 'markdown' THEN (
            SELECT jsonb_build_object(
                'markdown', markdown, 
                'objectKey', object_key, 
                'mediaExt', media_ext
            )
            FROM markdown_sections
            WHERE section_id = s.id
        )
        WHEN 'video' THEN (
            SELECT jsonb_build_object(
                'url', url, 'objectKey', 
                object_key, 'mediaExt', 
                media_ext
            )
            FROM video_sections
            WHERE section_id = s.id
        )
        WHEN 'question' THEN (
            SELECT jsonb_build_object(
                'id', q.id,
                'objectKey', object_key,
                'mediaExt', media_ext,
                'question', q.question,
                'type', q.type,
                'options', (
                    SELECT jsonb_agg(jsonb_build_object(
                        'id', qo.id,
                        'content', qo.content,
                        'isCorrect', qo.is_correct
                    ))
                    FROM question_options qo
                    WHERE qo.question_id = q.id
                )
            )
            FROM question_sections qs
            JOIN questions q ON q.id = qs.question_id
            WHERE qs.section_id = s.id
        )
        WHEN 'lottie' THEN (
            SELECT jsonb_build_object(
                'caption', caption,
                'description', description,
                'objectKey', object_key,
                'mediaExt', media_ext,
                'width', width,
                'height', height,
                'altText', alt_text,
                'fallbackUrl', fallback_url,
                'autoplay', autoplay,
                'loop', loop,
                'speed', speed
            )
            FROM lottie_sections
            WHERE section_id = s.id
        )
        WHEN 'code' THEN (
            SELECT jsonb_build_object(
                'code', code, 
                'language', language,
                'objectKey', object_key,
                'mediaExt', media_ext
            )
            FROM code_sections
            WHERE section_id = s.id
        )
        WHEN 'image' THEN (
            SELECT jsonb_build_object(
                'url', url, 
                'width', width,
                'height', height,
                'objectKey', object_key,
                'mediaExt', media_ext,
                'headline', headline,
                'caption', caption
            )
            FROM code_sections
            WHERE section_id = s.id
        )
    END as content
FROM sections s
WHERE s.id = $1::int
`

func (q *Queries) GetSectionContent(ctx context.Context, sectionID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getSectionContent, sectionID)
	var content interface{}
	err := row.Scan(&content)
	return content, err
}

const getUnitModules = `-- name: GetUnitModules :many
SELECT
    id,
    folder_object_key,
    img_key,
    media_ext,
    created_at,
    updated_at,
    module_number,
    unit_id,
    name,
    description
FROM modules
WHERE
    unit_id = $1::int
ORDER BY module_number
`

type GetUnitModulesRow struct {
	ID              int32          `json:"id"`
	FolderObjectKey uuid.NullUUID  `json:"folderObjectKey"`
	ImgKey          uuid.NullUUID  `json:"imgKey"`
	MediaExt        sql.NullString `json:"mediaExt"`
	CreatedAt       time.Time      `json:"createdAt"`
	UpdatedAt       time.Time      `json:"updatedAt"`
	ModuleNumber    int32          `json:"moduleNumber"`
	UnitID          int32          `json:"unitId"`
	Name            string         `json:"name"`
	Description     string         `json:"description"`
}

func (q *Queries) GetUnitModules(ctx context.Context, unitID int32) ([]GetUnitModulesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnitModules, unitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnitModulesRow{}
	for rows.Next() {
		var i GetUnitModulesRow
		if err := rows.Scan(
			&i.ID,
			&i.FolderObjectKey,
			&i.ImgKey,
			&i.MediaExt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ModuleNumber,
			&i.UnitID,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideoSection = `-- name: GetVideoSection :one
SELECT 
    url as url,
    object_key as object_key,
    media_ext as media_ext
FROM video_sections
WHERE section_id = $1::int
`

type GetVideoSectionRow struct {
	Url       string         `json:"url"`
	ObjectKey uuid.NullUUID  `json:"objectKey"`
	MediaExt  sql.NullString `json:"mediaExt"`
}

func (q *Queries) GetVideoSection(ctx context.Context, sectionID int32) (GetVideoSectionRow, error) {
	row := q.db.QueryRowContext(ctx, getVideoSection, sectionID)
	var i GetVideoSectionRow
	err := row.Scan(&i.Url, &i.ObjectKey, &i.MediaExt)
	return i, err
}

const initializeModuleProgress = `-- name: InitializeModuleProgress :exec
INSERT INTO user_module_progress
    (user_id, module_id, progress, status)
VALUES 
    ($1::int, $2::int, 0, 'uninitiated'::module_progress_status)
ON CONFLICT (user_id, module_id) DO NOTHING
`

type InitializeModuleProgressParams struct {
	UserID   int32 `json:"userId"`
	ModuleID int32 `json:"moduleId"`
}

func (q *Queries) InitializeModuleProgress(ctx context.Context, arg InitializeModuleProgressParams) error {
	_, err := q.db.ExecContext(ctx, initializeModuleProgress, arg.UserID, arg.ModuleID)
	return err
}

const insertCourseAuthor = `-- name: InsertCourseAuthor :exec
INSERT INTO course_authors (course_id, user_id)
VALUES ($1::int, $2::int)
`

type InsertCourseAuthorParams struct {
	CourseID int32 `json:"courseId"`
	UserID   int32 `json:"userId"`
}

func (q *Queries) InsertCourseAuthor(ctx context.Context, arg InsertCourseAuthorParams) error {
	_, err := q.db.ExecContext(ctx, insertCourseAuthor, arg.CourseID, arg.UserID)
	return err
}

const insertCourseTag = `-- name: InsertCourseTag :exec
INSERT INTO course_tags (course_id, tag_id)
VALUES ($1::int, $2::int)
`

type InsertCourseTagParams struct {
	CourseID int32 `json:"courseId"`
	TagID    int32 `json:"tagId"`
}

func (q *Queries) InsertCourseTag(ctx context.Context, arg InsertCourseTagParams) error {
	_, err := q.db.ExecContext(ctx, insertCourseTag, arg.CourseID, arg.TagID)
	return err
}

const publishCourse = `-- name: PublishCourse :exec
UPDATE courses
SET draft = FALSE
WHERE id = $1::int
`

func (q *Queries) PublishCourse(ctx context.Context, courseID int32) error {
	_, err := q.db.ExecContext(ctx, publishCourse, courseID)
	return err
}

const removeCourseTag = `-- name: RemoveCourseTag :exec
DELETE FROM course_tags
WHERE course_id = $1::int
AND tag_id = $2::int
`

type RemoveCourseTagParams struct {
	CourseID int32 `json:"courseId"`
	TagID    int32 `json:"tagId"`
}

func (q *Queries) RemoveCourseTag(ctx context.Context, arg RemoveCourseTagParams) error {
	_, err := q.db.ExecContext(ctx, removeCourseTag, arg.CourseID, arg.TagID)
	return err
}

const searchCourseTags = `-- name: SearchCourseTags :many
SELECT t.id, t.name, COUNT(*) OVER() as total_count
FROM tags t
    JOIN course_tags ct ON ct.tag_id = t.id
WHERE
    t.name ILIKE '%' || $1::text || '%'
ORDER BY t.name ASC
LIMIT $3::int
OFFSET $2::int
`

type SearchCourseTagsParams struct {
	SearchQuery string `json:"searchQuery"`
	PageOffset  int32  `json:"pageOffset"`
	PageLimit   int32  `json:"pageLimit"`
}

type SearchCourseTagsRow struct {
	ID         int32  `json:"id"`
	Name       string `json:"name"`
	TotalCount int64  `json:"totalCount"`
}

func (q *Queries) SearchCourseTags(ctx context.Context, arg SearchCourseTagsParams) ([]SearchCourseTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchCourseTags, arg.SearchQuery, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCourseTagsRow{}
	for rows.Next() {
		var i SearchCourseTagsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCourses = `-- name: SearchCourses :many
SELECT
    c.id,
    c.folder_object_key,
    c.created_at,
    c.updated_at,
    c.name,
    c.description,
    c.requirements,
    c.what_you_learn,
    c.background_color,
    c.img_key,
    c.duration,
    c.difficulty_level,
    c.rating,
    COUNT(*) OVER() as total_count
FROM courses c
WHERE 
    (LOWER(c.name) LIKE LOWER($1::text) OR
     LOWER(c.description) LIKE LOWER($1::text) OR
     EXISTS (
        SELECT 1 FROM course_tags ct
        JOIN tags t ON t.id = ct.tag_id
        WHERE ct.course_id = c.id AND LOWER(t.name) LIKE LOWER($1::text)
    ))
ORDER BY 
    CASE 
        WHEN LOWER(c.name) LIKE LOWER($1::text) THEN 1
        WHEN LOWER(c.description) LIKE LOWER($1::text) THEN 2
        ELSE 3
    END,
    c.created_at DESC
LIMIT $3::int
OFFSET $2::int
`

type SearchCoursesParams struct {
	SearchQuery string `json:"searchQuery"`
	PageOffset  int32  `json:"pageOffset"`
	PageLimit   int32  `json:"pageLimit"`
}

type SearchCoursesRow struct {
	ID              int32               `json:"id"`
	FolderObjectKey uuid.NullUUID       `json:"folderObjectKey"`
	CreatedAt       time.Time           `json:"createdAt"`
	UpdatedAt       time.Time           `json:"updatedAt"`
	Name            string              `json:"name"`
	Description     string              `json:"description"`
	Requirements    sql.NullString      `json:"requirements"`
	WhatYouLearn    sql.NullString      `json:"whatYouLearn"`
	BackgroundColor sql.NullString      `json:"backgroundColor"`
	ImgKey          uuid.NullUUID       `json:"imgKey"`
	Duration        sql.NullInt32       `json:"duration"`
	DifficultyLevel NullDifficultyLevel `json:"difficultyLevel"`
	Rating          sql.NullFloat64     `json:"rating"`
	TotalCount      int64               `json:"totalCount"`
}

func (q *Queries) SearchCourses(ctx context.Context, arg SearchCoursesParams) ([]SearchCoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchCourses, arg.SearchQuery, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCoursesRow{}
	for rows.Next() {
		var i SearchCoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.FolderObjectKey,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Requirements,
			&i.WhatYouLearn,
			&i.BackgroundColor,
			&i.ImgKey,
			&i.Duration,
			&i.DifficultyLevel,
			&i.Rating,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCoursesFullText = `-- name: SearchCoursesFullText :many
SELECT
    c.id,
    c.folder_object_key,
    c.created_at,
    c.updated_at,
    c.name,
    c.description,
    c.requirements,
    c.what_you_learn,
    c.background_color,
    c.img_key,
    c.duration,
    c.difficulty_level,
    c.rating,
    COUNT(*) OVER() as total_count,
    ts_rank(
        setweight(to_tsvector('english', c.name), 'A') ||
        setweight(to_tsvector('english', COALESCE(c.description, '')), 'B') ||
        setweight(to_tsvector('english', COALESCE(c.requirements, '')), 'C') ||
        setweight(to_tsvector('english', COALESCE(c.what_you_learn, '')), 'C'),
        plainto_tsquery('english', $1::text)
    ) as rank
FROM courses c
WHERE 
    to_tsvector('english', c.name) ||
    to_tsvector('english', COALESCE(c.description, '')) ||
    to_tsvector('english', COALESCE(c.requirements, '')) ||
    to_tsvector('english', COALESCE(c.what_you_learn, '')) @@
    plainto_tsquery('english', $1::text)
ORDER BY rank DESC, c.created_at DESC
LIMIT $3::int
OFFSET $2::int
`

type SearchCoursesFullTextParams struct {
	SearchQuery string `json:"searchQuery"`
	PageOffset  int32  `json:"pageOffset"`
	PageLimit   int32  `json:"pageLimit"`
}

type SearchCoursesFullTextRow struct {
	ID              int32               `json:"id"`
	FolderObjectKey uuid.NullUUID       `json:"folderObjectKey"`
	CreatedAt       time.Time           `json:"createdAt"`
	UpdatedAt       time.Time           `json:"updatedAt"`
	Name            string              `json:"name"`
	Description     string              `json:"description"`
	Requirements    sql.NullString      `json:"requirements"`
	WhatYouLearn    sql.NullString      `json:"whatYouLearn"`
	BackgroundColor sql.NullString      `json:"backgroundColor"`
	ImgKey          uuid.NullUUID       `json:"imgKey"`
	Duration        sql.NullInt32       `json:"duration"`
	DifficultyLevel NullDifficultyLevel `json:"difficultyLevel"`
	Rating          sql.NullFloat64     `json:"rating"`
	TotalCount      int64               `json:"totalCount"`
	Rank            float32             `json:"rank"`
}

func (q *Queries) SearchCoursesFullText(ctx context.Context, arg SearchCoursesFullTextParams) ([]SearchCoursesFullTextRow, error) {
	rows, err := q.db.QueryContext(ctx, searchCoursesFullText, arg.SearchQuery, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCoursesFullTextRow{}
	for rows.Next() {
		var i SearchCoursesFullTextRow
		if err := rows.Scan(
			&i.ID,
			&i.FolderObjectKey,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Requirements,
			&i.WhatYouLearn,
			&i.BackgroundColor,
			&i.ImgKey,
			&i.Duration,
			&i.DifficultyLevel,
			&i.Rating,
			&i.TotalCount,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startCourseUserCourses = `-- name: StartCourseUserCourses :exec
INSERT INTO user_courses 
    (user_id, course_id)
VALUES 
    ($1::int, $2::int)
ON CONFLICT (user_id, course_id) DO NOTHING
`

type StartCourseUserCoursesParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

func (q *Queries) StartCourseUserCourses(ctx context.Context, arg StartCourseUserCoursesParams) error {
	_, err := q.db.ExecContext(ctx, startCourseUserCourses, arg.UserID, arg.CourseID)
	return err
}

const updateCourse = `-- name: UpdateCourse :exec
UPDATE courses
SET
    name = CASE 
        WHEN $1::text = '' THEN name 
        ELSE $1::text 
    END,
    description = CASE 
        WHEN $2::text = '' THEN description 
        ELSE $2::text 
    END,
    folder_object_key = CASE 
        WHEN $3::UUID IS NULL THEN folder_object_key 
        ELSE $3::UUID 
    END,
    media_ext = CASE 
        WHEN $4::text = '' THEN media_ext 
        ELSE $4::text 
    END,
    requirements = CASE 
        WHEN $5::text = '' THEN requirements 
        ELSE $5::text 
    END,
    what_you_learn = CASE 
        WHEN $6::text = '' THEN what_you_learn 
        ELSE $6::text 
    END,
    background_color = CASE 
        WHEN $7::text = '' THEN background_color 
        ELSE $7::text 
    END,
    img_key = CASE 
        WHEN $8::UUID IS NULL THEN img_key 
        ELSE $8::UUID 
    END,
    duration = CASE 
        WHEN $9::int = 0 THEN duration 
        ELSE $9::int 
    END,
    difficulty_level = CASE 
        WHEN $10::text = '' THEN difficulty_level 
        ELSE $10::difficulty_level 
    END,
    rating = CASE 
        WHEN $11::float < 0 THEN rating 
        ELSE $11::float 
    END
WHERE id = $12::int
`

type UpdateCourseParams struct {
	Name            string    `json:"name"`
	Description     string    `json:"description"`
	FolderObjectKey uuid.UUID `json:"folderObjectKey"`
	MediaExt        string    `json:"mediaExt"`
	Requirements    string    `json:"requirements"`
	WhatYouLearn    string    `json:"whatYouLearn"`
	BackgroundColor string    `json:"backgroundColor"`
	ImgKey          uuid.UUID `json:"imgKey"`
	Duration        int32     `json:"duration"`
	DifficultyLevel string    `json:"difficultyLevel"`
	Rating          float64   `json:"rating"`
	CourseID        int32     `json:"courseId"`
}

func (q *Queries) UpdateCourse(ctx context.Context, arg UpdateCourseParams) error {
	_, err := q.db.ExecContext(ctx, updateCourse,
		arg.Name,
		arg.Description,
		arg.FolderObjectKey,
		arg.MediaExt,
		arg.Requirements,
		arg.WhatYouLearn,
		arg.BackgroundColor,
		arg.ImgKey,
		arg.Duration,
		arg.DifficultyLevel,
		arg.Rating,
		arg.CourseID,
	)
	return err
}
