// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: modules.sql

package gen

import (
	"context"
	"encoding/json"
)

const createModule = `-- name: CreateModule :one
INSERT INTO modules (
    module_number,
    unit_id,
    name,
    description
) VALUES (
    (
        SELECT COALESCE(MAX(module_number), 0) + 1
        FROM modules
        WHERE unit_id = $1::int
    ),
    $1::int,
    $2::text,
    $3::text
) RETURNING id, created_at, updated_at, module_number, unit_id, name, description
`

type CreateModuleParams struct {
	UnitID      int32  `json:"unitId"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreateModule(ctx context.Context, arg CreateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, createModule, arg.UnitID, arg.Name, arg.Description)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const deleteModule = `-- name: DeleteModule :exec
DELETE FROM modules WHERE id = $1::int
`

func (q *Queries) DeleteModule(ctx context.Context, moduleID int32) error {
	_, err := q.db.ExecContext(ctx, deleteModule, moduleID)
	return err
}

const getModuleTotalCount = `-- name: GetModuleTotalCount :one
SELECT COUNT(*) FROM modules m WHERE m.unit_id = $1::int
`

func (q *Queries) GetModuleTotalCount(ctx context.Context, unitID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getModuleTotalCount, unitID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getModuleWithProgress = `-- name: GetModuleWithProgress :one
WITH section_content AS (
    SELECT s.id as section_id, 
        CASE s.type
            WHEN 'text' THEN (
                SELECT jsonb_build_object('text', text_content)
                FROM text_sections ts
                WHERE ts.section_id = s.id
            )
            WHEN 'video' THEN (
                SELECT jsonb_build_object('url', url)
                FROM video_sections vs
                WHERE vs.section_id = s.id
            )
            WHEN 'question' THEN (
                SELECT jsonb_build_object(
                    'id', q.id,
                    'question', q.question,
                    'type', q.type,
                    'options', COALESCE(
                        (SELECT jsonb_agg(
                            jsonb_build_object(
                                'id', qo.id,
                                'content', qo.content,
                                'isCorrect', qo.is_correct
                            ) ORDER BY qo.id
                        )
                        FROM question_options qo
                        WHERE qo.question_id = q.id
                        ), '[]'::jsonb),
                    'userQuestionAnswer', (
                        SELECT jsonb_build_object(
                            'optionId', uqa.option_id,
                            'answeredAt', uqa.answered_at,
                            'isCorrect', uqa.is_correct
                        )
                        FROM user_question_answers uqa
                        JOIN user_module_progress ump2 ON ump2.id = uqa.user_module_progress_id
                        WHERE ump2.user_id = $1::int
                        AND uqa.question_id = q.id
                    )
                )
                FROM question_sections qs
                JOIN questions q ON q.id = qs.question_id
                WHERE qs.section_id = s.id
            )
        END as content
    FROM sections s
    WHERE s.module_id = $3::int
),
section_progress AS (
    SELECT 
        s.id as section_id,
        jsonb_build_object(
            'sectionId', s.id,
            'seenAt', usp.seen_at,
            'hasSeen', usp.has_seen,
            'startedAt', usp.started_at,
            'completedAt', usp.completed_at
        ) as progress
    FROM sections s
    LEFT JOIN user_section_progress usp ON usp.section_id = s.id 
    AND usp.user_id = $1::int
    WHERE s.module_id = $3::int
),
unit_modules AS (
    SELECT id, module_number
    FROM modules
    WHERE unit_id = $2::int
    ORDER BY module_number ASC
),
current_module AS (
    SELECT id, module_number
    FROM unit_modules
    WHERE id = $3::int
)
SELECT
    jsonb_build_object(
        'id', m.id,
        'createdAt', m.created_at,
        'updatedAt', m.updated_at,
        'moduleNumber', m.module_number,
        'unitId', m.unit_id,
        'name', m.name,
        'description', m.description,
        'progress', ump.progress,
        'status', ump.status,
        'sections', COALESCE((
            SELECT jsonb_agg(
                jsonb_build_object(
                    'id', s.id,
                    'createdAt', s.created_at,
                    'updatedAt', s.updated_at,
                    'type', s.type,
                    'position', s.position,
                    'content', sc.content,
                    'sectionProgress', sp.progress
                )
                ORDER BY s.position
            )
            FROM sections s
            LEFT JOIN section_content sc ON sc.section_id = s.id
            LEFT JOIN section_progress sp ON sp.section_id = s.id
            WHERE s.module_id = m.id
        ), '[]'::jsonb)
    ) as module,
    (
        SELECT id
        FROM unit_modules
        WHERE module_number > (SELECT module_number FROM current_module)
        ORDER BY module_number ASC LIMIT 1
    ) as next_module_id,
    EXISTS (
        SELECT 1
        FROM unit_modules
        WHERE module_number > (SELECT module_number FROM current_module)
        LIMIT 1
    ) as has_next_module
FROM modules m
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
WHERE m.unit_id = $2::int AND m.id = $3::int
`

type GetModuleWithProgressParams struct {
	UserID   int32 `json:"userId"`
	UnitID   int32 `json:"unitId"`
	ModuleID int32 `json:"moduleId"`
}

type GetModuleWithProgressRow struct {
	Module        json.RawMessage `json:"module"`
	NextModuleID  int32           `json:"nextModuleId"`
	HasNextModule bool            `json:"hasNextModule"`
}

func (q *Queries) GetModuleWithProgress(ctx context.Context, arg GetModuleWithProgressParams) (GetModuleWithProgressRow, error) {
	row := q.db.QueryRowContext(ctx, getModuleWithProgress, arg.UserID, arg.UnitID, arg.ModuleID)
	var i GetModuleWithProgressRow
	err := row.Scan(&i.Module, &i.NextModuleID, &i.HasNextModule)
	return i, err
}

const getModulesWithProgress = `-- name: GetModulesWithProgress :one
WITH section_content AS (
    SELECT s.id as section_id, s.module_id,
        CASE s.type
            WHEN 'text' THEN (
                SELECT jsonb_build_object('text', text_content)
                FROM text_sections ts
                WHERE ts.section_id = s.id
            )
            WHEN 'video' THEN (
                SELECT jsonb_build_object('url', url)
                FROM video_sections vs
                WHERE vs.section_id = s.id
            )
            WHEN 'question' THEN (
                SELECT jsonb_build_object(
                    'id', q.id,
                    'question', q.question,
                    'type', q.type,
                    'options', COALESCE(
                        (SELECT jsonb_agg(
                            jsonb_build_object(
                                'id', qo.id,
                                'content', qo.content,
                                'isCorrect', qo.is_correct
                            ) ORDER BY qo.id
                        )
                        FROM question_options qo
                        WHERE qo.question_id = q.id
                        ), '[]'::jsonb),
                    'userQuestionAnswer', (
                        SELECT jsonb_build_object(
                            'optionId', uqa.option_id,
                            'answeredAt', uqa.answered_at,
                            'isCorrect', uqa.is_correct
                        )
                        FROM user_question_answers uqa
                        JOIN user_module_progress ump2 ON ump2.id = uqa.user_module_progress_id
                        WHERE ump2.user_id = $1::int
                        AND uqa.question_id = q.id
                    )
                )
                FROM question_sections qs
                JOIN questions q ON q.id = qs.question_id
                WHERE qs.section_id = s.id
            )
        END as content
    FROM sections s
    WHERE s.module_id IN (SELECT id FROM modules WHERE unit_id = $2::int)
),
section_progress AS (
    SELECT 
        s.id as section_id,
        s.module_id,
        jsonb_build_object(
            'sectionId', s.id,
            'seenAt', usp.seen_at,
            'hasSeen', usp.has_seen,
            'startedAt', usp.started_at,
            'completedAt', usp.completed_at
        ) as progress
    FROM sections s
    LEFT JOIN user_section_progress usp ON usp.section_id = s.id 
    AND usp.user_id = $1::int
    WHERE s.module_id IN (SELECT id FROM modules WHERE unit_id = $2::int)
),
unit_modules AS (
    SELECT id, created_at, updated_at, module_number, unit_id, name, description
    FROM modules
    WHERE unit_id = $2::int
    ORDER BY module_number
    LIMIT $4::int
    OFFSET $3::int
)
SELECT COALESCE(
    jsonb_agg(
        jsonb_build_object(
            'id', m.id,
            'createdAt', m.created_at,
            'updatedAt', m.updated_at,
            'moduleNumber', m.module_number,
            'unitId', m.unit_id,
            'name', m.name,
            'description', m.description,
            'progress', ump.progress,
            'status', ump.status,
            'sections', COALESCE((
                SELECT jsonb_agg(
                    jsonb_build_object(
                        'id', s.id,
                        'createdAt', s.created_at,
                        'updatedAt', s.updated_at,
                        'type', s.type,
                        'position', s.position,
                        'content', sc.content,
                        'sectionProgress', sp.progress
                    )
                    ORDER BY s.position
                )
                FROM sections s
                LEFT JOIN section_content sc ON sc.section_id = s.id
                LEFT JOIN section_progress sp ON sp.section_id = s.id
                WHERE s.module_id = m.id
            ), '[]'::jsonb)
        )
    ), '[]'::jsonb
) as modules
FROM unit_modules m
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
`

type GetModulesWithProgressParams struct {
	UserID     int32 `json:"userId"`
	UnitID     int32 `json:"unitId"`
	PageOffset int32 `json:"pageOffset"`
	PageSize   int32 `json:"pageSize"`
}

func (q *Queries) GetModulesWithProgress(ctx context.Context, arg GetModulesWithProgressParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getModulesWithProgress,
		arg.UserID,
		arg.UnitID,
		arg.PageOffset,
		arg.PageSize,
	)
	var modules interface{}
	err := row.Scan(&modules)
	return modules, err
}

const saveModuleProgress = `-- name: SaveModuleProgress :exec
SELECT save_module_progress($1::int, $2::int, $3::jsonb, $4::jsonb)
`

type SaveModuleProgressParams struct {
	UserID    int32           `json:"userId"`
	ModuleID  int32           `json:"moduleId"`
	Sections  json.RawMessage `json:"sections"`
	Questions json.RawMessage `json:"questions"`
}

func (q *Queries) SaveModuleProgress(ctx context.Context, arg SaveModuleProgressParams) error {
	_, err := q.db.ExecContext(ctx, saveModuleProgress,
		arg.UserID,
		arg.ModuleID,
		arg.Sections,
		arg.Questions,
	)
	return err
}

const updateModule = `-- name: UpdateModule :one
UPDATE modules
SET
    name = COALESCE(NULLIF($1::text, ''), name),
    description = COALESCE(NULLIF($2::text, ''), description),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3::int
RETURNING id, created_at, updated_at, module_number, unit_id, name, description
`

type UpdateModuleParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ModuleID    int32  `json:"moduleId"`
}

func (q *Queries) UpdateModule(ctx context.Context, arg UpdateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, updateModule, arg.Name, arg.Description, arg.ModuleID)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}
