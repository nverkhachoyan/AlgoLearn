// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: modules.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const calculateCourseProgress = `-- name: CalculateCourseProgress :one
SELECT
    CASE
        WHEN COUNT(*) = 0 THEN 0::float
        ELSE (
            COUNT(CASE WHEN ump.status = 'completed' THEN 1 END)::FLOAT /
            COUNT(*)::FLOAT
        ) * 100
    END as progress
FROM modules m
JOIN units u ON m.unit_id = u.id
LEFT JOIN user_module_progress ump
    ON ump.module_id = m.id
    AND ump.user_id = $1
WHERE u.course_id = $2
`

type CalculateCourseProgressParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

func (q *Queries) CalculateCourseProgress(ctx context.Context, arg CalculateCourseProgressParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, calculateCourseProgress, arg.UserID, arg.CourseID)
	var progress interface{}
	err := row.Scan(&progress)
	return progress, err
}

const calculateModuleProgress = `-- name: CalculateModuleProgress :one
SELECT
    CASE
        WHEN COUNT(*) = 0 THEN 0::float
        ELSE (
            COUNT(CASE
                WHEN s.type = 'question' THEN
                    CASE WHEN uqa.is_correct THEN 1 END
                ELSE
                    CASE WHEN usp.has_seen THEN 1 END
            END)::FLOAT / COUNT(*)::FLOAT
        ) * 100
    END as progress
FROM sections s
LEFT JOIN user_section_progress usp
    ON usp.section_id = s.id
    AND usp.user_id = $1
LEFT JOIN question_sections qs
    ON s.id = qs.section_id
LEFT JOIN user_question_answers uqa
    ON qs.question_id = uqa.question_id
    AND uqa.user_module_progress_id = $2
WHERE s.module_id = $3
`

type CalculateModuleProgressParams struct {
	UserID               int32 `json:"userId"`
	UserModuleProgressID int32 `json:"userModuleProgressId"`
	ModuleID             int32 `json:"moduleId"`
}

func (q *Queries) CalculateModuleProgress(ctx context.Context, arg CalculateModuleProgressParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, calculateModuleProgress, arg.UserID, arg.UserModuleProgressID, arg.ModuleID)
	var progress interface{}
	err := row.Scan(&progress)
	return progress, err
}

const createModule = `-- name: CreateModule :one
WITH new_module AS (
    SELECT COALESCE(MAX(module_number), 0) + 1 as next_number
    FROM modules
    WHERE unit_id = $1::int
)
INSERT INTO modules (
    module_number,
    unit_id,
    name,
    description,
    folder_object_key,
    img_key,
    media_ext
) VALUES (
    (SELECT next_number FROM new_module),
    $1::int,
    $2::text,
    COALESCE($3::text, ''),
    COALESCE($4::UUID, NULL),
    COALESCE($5::UUID, NULL),
    COALESCE($6::text, '')
)
RETURNING id, folder_object_key, created_at, updated_at, img_key, media_ext, draft, module_number, unit_id, name, description
`

type CreateModuleParams struct {
	UnitID          int32     `json:"unitId"`
	Name            string    `json:"name"`
	Description     string    `json:"description"`
	FolderObjectKey uuid.UUID `json:"folderObjectKey"`
	ImgKey          uuid.UUID `json:"imgKey"`
	MediaExt        string    `json:"mediaExt"`
}

func (q *Queries) CreateModule(ctx context.Context, arg CreateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, createModule,
		arg.UnitID,
		arg.Name,
		arg.Description,
		arg.FolderObjectKey,
		arg.ImgKey,
		arg.MediaExt,
	)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.FolderObjectKey,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImgKey,
		&i.MediaExt,
		&i.Draft,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const deleteModule = `-- name: DeleteModule :exec
DELETE FROM modules WHERE id = $1::int
`

func (q *Queries) DeleteModule(ctx context.Context, moduleID int32) error {
	_, err := q.db.ExecContext(ctx, deleteModule, moduleID)
	return err
}

const getCourseAndUnitIDs = `-- name: GetCourseAndUnitIDs :one
SELECT u.course_id, m.unit_id
FROM modules m
    JOIN units u ON m.unit_id = u.id
WHERE
    m.id = $1
`

type GetCourseAndUnitIDsRow struct {
	CourseID int32 `json:"courseId"`
	UnitID   int32 `json:"unitId"`
}

func (q *Queries) GetCourseAndUnitIDs(ctx context.Context, id int32) (GetCourseAndUnitIDsRow, error) {
	row := q.db.QueryRowContext(ctx, getCourseAndUnitIDs, id)
	var i GetCourseAndUnitIDsRow
	err := row.Scan(&i.CourseID, &i.UnitID)
	return i, err
}

const getFirstModuleIdInUnit = `-- name: GetFirstModuleIdInUnit :one
SELECT id
FROM modules
WHERE unit_id = $1::int
ORDER BY module_number ASC
LIMIT 1
`

func (q *Queries) GetFirstModuleIdInUnit(ctx context.Context, unitID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getFirstModuleIdInUnit, unitID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getFurthestModuleID = `-- name: GetFurthestModuleID :one
SELECT furthest_module_id
FROM user_courses
WHERE user_id = $1::int
  AND course_id = $2::int
`

type GetFurthestModuleIDParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

func (q *Queries) GetFurthestModuleID(ctx context.Context, arg GetFurthestModuleIDParams) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getFurthestModuleID, arg.UserID, arg.CourseID)
	var furthest_module_id sql.NullInt32
	err := row.Scan(&furthest_module_id)
	return furthest_module_id, err
}

const getLastModuleNumber = `-- name: GetLastModuleNumber :one
SELECT COALESCE(MAX(module_number), 0) as last_number
FROM modules
WHERE
    unit_id = $1::int
`

func (q *Queries) GetLastModuleNumber(ctx context.Context, unitID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLastModuleNumber, unitID)
	var last_number interface{}
	err := row.Scan(&last_number)
	return last_number, err
}

const getModuleByID = `-- name: GetModuleByID :one
SELECT id, folder_object_key, created_at, updated_at, img_key, media_ext, draft, module_number, unit_id, name, description FROM modules WHERE id = $1::int
`

func (q *Queries) GetModuleByID(ctx context.Context, id int32) (Module, error) {
	row := q.db.QueryRowContext(ctx, getModuleByID, id)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.FolderObjectKey,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImgKey,
		&i.MediaExt,
		&i.Draft,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const getModuleTotalCountByUnitId = `-- name: GetModuleTotalCountByUnitId :one
SELECT COUNT(*) FROM modules WHERE unit_id = $1::int
`

func (q *Queries) GetModuleTotalCountByUnitId(ctx context.Context, unitID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getModuleTotalCountByUnitId, unitID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getModuleWithProgress = `-- name: GetModuleWithProgress :one
SELECT jsonb_build_object(
    'id', m.id,
    'createdAt', m.created_at,
    'updatedAt', m.updated_at,
    'folderObjectKey', m.folder_object_key,
    'imgKey', m.img_key,
    'mediaExt', m.media_ext,
    'moduleNumber', m.module_number,
    'unitId', m.unit_id,
    'name', m.name,
    'description', m.description,
    'progress', COALESCE(ump.progress, 0.0),
    'status', COALESCE(ump.status, 'uninitiated'::module_progress_status),
    'startedAt', ump.started_at,
    'completedAt', ump.completed_at,
    'lastAccessed', ump.last_accessed
) as module
FROM modules m
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
WHERE m.unit_id = $2::int AND m.id = $3::int
`

type GetModuleWithProgressParams struct {
	UserID   int32 `json:"userId"`
	UnitID   int32 `json:"unitId"`
	ModuleID int32 `json:"moduleId"`
}

func (q *Queries) GetModuleWithProgress(ctx context.Context, arg GetModuleWithProgressParams) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getModuleWithProgress, arg.UserID, arg.UnitID, arg.ModuleID)
	var module json.RawMessage
	err := row.Scan(&module)
	return module, err
}

const getModulesByUnitId = `-- name: GetModulesByUnitId :many
SELECT id, folder_object_key, created_at, updated_at, img_key, media_ext, draft, module_number, unit_id, name, description FROM modules WHERE unit_id = $1::int
`

func (q *Queries) GetModulesByUnitId(ctx context.Context, unitID int32) ([]Module, error) {
	rows, err := q.db.QueryContext(ctx, getModulesByUnitId, unitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Module{}
	for rows.Next() {
		var i Module
		if err := rows.Scan(
			&i.ID,
			&i.FolderObjectKey,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImgKey,
			&i.MediaExt,
			&i.Draft,
			&i.ModuleNumber,
			&i.UnitID,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModulesCount = `-- name: GetModulesCount :one
SELECT COUNT(*) FROM modules
`

func (q *Queries) GetModulesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getModulesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getModulesList = `-- name: GetModulesList :many
SELECT
    m.id, m.folder_object_key, m.created_at, m.updated_at, m.img_key, m.media_ext, m.draft, m.module_number, m.unit_id, m.name, m.description,
    jsonb_build_object(
        'folderObjectKey', m.folder_object_key,
        'imgKey', m.img_key,
        'mediaExt', m.media_ext,
        'progress', COALESCE(ump.progress, 0.0),
        'status', COALESCE(ump.status, 'uninitiated'::module_progress_status),
        'startedAt', ump.started_at,
        'completedAt', ump.completed_at,
        'lastAccessed', ump.last_accessed,
        'currentSectionId', ump.current_section_id
    )::json as module_progress
FROM modules m
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
WHERE m.unit_id = $2::int
ORDER BY m.module_number
LIMIT $4::int
OFFSET $3::int
`

type GetModulesListParams struct {
	UserID     int32 `json:"userId"`
	UnitID     int32 `json:"unitId"`
	PageOffset int32 `json:"pageOffset"`
	PageSize   int32 `json:"pageSize"`
}

type GetModulesListRow struct {
	ID              int32           `json:"id"`
	FolderObjectKey uuid.NullUUID   `json:"folderObjectKey"`
	CreatedAt       time.Time       `json:"createdAt"`
	UpdatedAt       time.Time       `json:"updatedAt"`
	ImgKey          uuid.NullUUID   `json:"imgKey"`
	MediaExt        sql.NullString  `json:"mediaExt"`
	Draft           bool            `json:"draft"`
	ModuleNumber    int32           `json:"moduleNumber"`
	UnitID          int32           `json:"unitId"`
	Name            string          `json:"name"`
	Description     string          `json:"description"`
	ModuleProgress  json.RawMessage `json:"moduleProgress"`
}

func (q *Queries) GetModulesList(ctx context.Context, arg GetModulesListParams) ([]GetModulesListRow, error) {
	rows, err := q.db.QueryContext(ctx, getModulesList,
		arg.UserID,
		arg.UnitID,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModulesListRow{}
	for rows.Next() {
		var i GetModulesListRow
		if err := rows.Scan(
			&i.ID,
			&i.FolderObjectKey,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImgKey,
			&i.MediaExt,
			&i.Draft,
			&i.ModuleNumber,
			&i.UnitID,
			&i.Name,
			&i.Description,
			&i.ModuleProgress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextModuleId = `-- name: GetNextModuleId :one
SELECT id
FROM modules
WHERE unit_id = $1::int
  AND module_number > $2::int
ORDER BY module_number ASC
LIMIT 1
`

type GetNextModuleIdParams struct {
	UnitID       int32 `json:"unitId"`
	ModuleNumber int32 `json:"moduleNumber"`
}

func (q *Queries) GetNextModuleId(ctx context.Context, arg GetNextModuleIdParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextModuleId, arg.UnitID, arg.ModuleNumber)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getNextModuleIdInUnitOrNextUnit = `-- name: GetNextModuleIdInUnitOrNextUnit :one
SELECT id
FROM modules
WHERE unit_id = $1::int
    OR unit_id = (
        SELECT id
        FROM units
        WHERE course_id = $2::int
            AND unit_number > $3::int
        ORDER BY unit_number ASC
        LIMIT 1
    )
ORDER BY module_number ASC
LIMIT 1
`

type GetNextModuleIdInUnitOrNextUnitParams struct {
	UnitID     int32 `json:"unitId"`
	CourseID   int32 `json:"courseId"`
	UnitNumber int32 `json:"unitNumber"`
}

func (q *Queries) GetNextModuleIdInUnitOrNextUnit(ctx context.Context, arg GetNextModuleIdInUnitOrNextUnitParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextModuleIdInUnitOrNextUnit, arg.UnitID, arg.CourseID, arg.UnitNumber)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getNextModuleNumber = `-- name: GetNextModuleNumber :one
SELECT module_number
FROM modules
WHERE unit_id = $1::int
    AND module_number > $2::int
ORDER BY module_number ASC
LIMIT 1
`

type GetNextModuleNumberParams struct {
	UnitID       int32 `json:"unitId"`
	ModuleNumber int32 `json:"moduleNumber"`
}

func (q *Queries) GetNextModuleNumber(ctx context.Context, arg GetNextModuleNumberParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextModuleNumber, arg.UnitID, arg.ModuleNumber)
	var module_number int32
	err := row.Scan(&module_number)
	return module_number, err
}

const getNextUnitId = `-- name: GetNextUnitId :one
SELECT id
FROM units
WHERE course_id = $1::int
  AND unit_number > $2::int
ORDER BY unit_number ASC
LIMIT 1
`

type GetNextUnitIdParams struct {
	CourseID   int32 `json:"courseId"`
	UnitNumber int32 `json:"unitNumber"`
}

func (q *Queries) GetNextUnitId(ctx context.Context, arg GetNextUnitIdParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextUnitId, arg.CourseID, arg.UnitNumber)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getNextUnitModuleId = `-- name: GetNextUnitModuleId :one
SELECT id
FROM modules
WHERE unit_id = $1::int
ORDER BY module_number ASC
LIMIT 1
`

func (q *Queries) GetNextUnitModuleId(ctx context.Context, unitID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextUnitModuleId, unitID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPrevModuleId = `-- name: GetPrevModuleId :one
SELECT id
FROM modules
WHERE unit_id = $1::int
  AND module_number < $2::int
ORDER BY module_number DESC
LIMIT 1
`

type GetPrevModuleIdParams struct {
	UnitID       int32 `json:"unitId"`
	ModuleNumber int32 `json:"moduleNumber"`
}

func (q *Queries) GetPrevModuleId(ctx context.Context, arg GetPrevModuleIdParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPrevModuleId, arg.UnitID, arg.ModuleNumber)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPrevUnitId = `-- name: GetPrevUnitId :one
SELECT id
FROM units
WHERE course_id = $1::int
  AND unit_number < $2::int
ORDER BY unit_number DESC
LIMIT 1
`

type GetPrevUnitIdParams struct {
	CourseID   int32 `json:"courseId"`
	UnitNumber int32 `json:"unitNumber"`
}

func (q *Queries) GetPrevUnitId(ctx context.Context, arg GetPrevUnitIdParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPrevUnitId, arg.CourseID, arg.UnitNumber)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPrevUnitModuleId = `-- name: GetPrevUnitModuleId :one
SELECT id
FROM modules
WHERE unit_id = $1::int
ORDER BY module_number DESC
LIMIT 1
`

func (q *Queries) GetPrevUnitModuleId(ctx context.Context, unitID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPrevUnitModuleId, unitID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getSectionProgress = `-- name: GetSectionProgress :many
SELECT
    section_id,
    jsonb_build_object(
        'sectionId', section_id,
        'seenAt', seen_at,
        'hasSeen', has_seen,
        'startedAt', started_at,
        'completedAt', completed_at,
        'progress', progress
    ) as progress
FROM user_section_progress
WHERE user_id = $1::int AND module_id = $2::int
`

type GetSectionProgressParams struct {
	UserID   int32 `json:"userId"`
	ModuleID int32 `json:"moduleId"`
}

type GetSectionProgressRow struct {
	SectionID int32           `json:"sectionId"`
	Progress  json.RawMessage `json:"progress"`
}

func (q *Queries) GetSectionProgress(ctx context.Context, arg GetSectionProgressParams) ([]GetSectionProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionProgress, arg.UserID, arg.ModuleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSectionProgressRow{}
	for rows.Next() {
		var i GetSectionProgressRow
		if err := rows.Scan(&i.SectionID, &i.Progress); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleModuleSections = `-- name: GetSingleModuleSections :many
WITH section_content AS (
    SELECT
        s.id as section_id,
        s.type::section_type as type,
        CASE s.type
            WHEN 'markdown' THEN (
                SELECT jsonb_build_object('markdown', markdown, 'objectKey', ms.object_key, 'media_ext', ms.media_ext)
                FROM markdown_sections ms
                WHERE ms.section_id = s.id
            )
            WHEN 'lottie' THEN (
                SELECT jsonb_build_object(
                    'caption', ls.caption,
                    'description', ls.description,
                    'objectKey', ls.object_key,
                    'width', ls.width,
                    'height', ls.height,
                    'alt_text', ls.alt_text,
                    'fallback_url', ls.fallback_url,
                    'autoplay', ls.autoplay,
                    'loop', ls.loop,
                    'speed', ls.speed,
                    'media_ext', ls.media_ext
                )
                FROM lottie_sections ls
                WHERE ls.section_id = s.id
            )
            WHEN 'video' THEN (
                SELECT jsonb_build_object('url', url, 'objectKey', vs.object_key, 'media_ext', vs.media_ext)
                FROM video_sections vs
                WHERE vs.section_id = s.id
            )
            WHEN 'question' THEN (
                SELECT jsonb_build_object(
                    'id', q.id,
                    'objectKey', qs.object_key,
                    'media_ext', qs.media_ext,
                    'question', q.question,
                    'type', q.type,
                    'options', COALESCE(
                        (SELECT jsonb_agg(
                            jsonb_build_object(
                                'id', qo.id,
                                'content', qo.content,
                                'isCorrect', qo.is_correct
                            ) ORDER BY qo.id
                        )
                        FROM question_options qo
                        WHERE qo.question_id = q.id
                        ), '[]'::jsonb),
                    'userQuestionAnswer', (
                        SELECT CASE
                            WHEN uqa.id IS NOT NULL THEN
                                jsonb_build_object(
                                    'optionId', uqa.option_id,
                                    'answeredAt', uqa.answered_at,
                                    'isCorrect', uqa.is_correct,
                                    'progress', uqa.progress
                                )
                            ELSE NULL
                        END
                        FROM question_sections qs2
                        LEFT JOIN user_module_progress ump ON ump.module_id = $1::int AND ump.user_id = $2::int
                        LEFT JOIN user_question_answers uqa ON uqa.user_module_progress_id = ump.id
                            AND uqa.question_id = q.id
                        WHERE qs2.section_id = s.id
                        LIMIT 1
                    )
                )
                FROM question_sections qs
                JOIN questions q ON q.id = qs.question_id
                WHERE qs.section_id = s.id
            )
            WHEN 'code' THEN (
                SELECT jsonb_build_object('code', code, 'language', language, 'objectKey', cs.object_key, 'media_ext', cs.media_ext)
                FROM code_sections cs
                WHERE cs.section_id = s.id
            )
        END as content
    FROM sections s
    WHERE s.module_id = $1::int
)
SELECT
    s.id,
    s.created_at,
    s.updated_at,
    s.type,
    s.position,
    COALESCE(sc.content, '{}'::jsonb)::json as content
FROM sections s
LEFT JOIN section_content sc ON sc.section_id = s.id
WHERE s.module_id = $1::int
ORDER BY s.position
`

type GetSingleModuleSectionsParams struct {
	ModuleID int32 `json:"moduleId"`
	UserID   int32 `json:"userId"`
}

type GetSingleModuleSectionsRow struct {
	ID        int32           `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	Type      SectionType     `json:"type"`
	Position  int32           `json:"position"`
	Content   json.RawMessage `json:"content"`
}

func (q *Queries) GetSingleModuleSections(ctx context.Context, arg GetSingleModuleSectionsParams) ([]GetSingleModuleSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSingleModuleSections, arg.ModuleID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSingleModuleSectionsRow{}
	for rows.Next() {
		var i GetSingleModuleSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Position,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitNumber = `-- name: GetUnitNumber :one
SELECT unit_number
FROM units
WHERE id = $1::int
`

func (q *Queries) GetUnitNumber(ctx context.Context, unitID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUnitNumber, unitID)
	var unit_number int32
	err := row.Scan(&unit_number)
	return unit_number, err
}

const insertCodeSection = `-- name: InsertCodeSection :exec
INSERT INTO
    code_sections (section_id, code, language, object_key, media_ext)
VALUES ($1, $2, $3, $4, $5)
`

type InsertCodeSectionParams struct {
	SectionID int32          `json:"sectionId"`
	Code      string         `json:"code"`
	Language  sql.NullString `json:"language"`
	ObjectKey uuid.NullUUID  `json:"objectKey"`
	MediaExt  sql.NullString `json:"mediaExt"`
}

func (q *Queries) InsertCodeSection(ctx context.Context, arg InsertCodeSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertCodeSection,
		arg.SectionID,
		arg.Code,
		arg.Language,
		arg.ObjectKey,
		arg.MediaExt,
	)
	return err
}

const insertLottieSection = `-- name: InsertLottieSection :exec
INSERT INTO
    lottie_sections (
    section_id, 
    caption, 
    description, 
    width, 
    height, 
    object_key,
    media_ext,
    alt_text, 
    fallback_url, 
    autoplay, 
    loop, 
    speed
)
VALUES (
    $1,
    $2, 
    $3, 
    $4, 
    $5, 
    $6, 
    $7,
    $8, 
    $9,
    $10, 
    $11, 
    $12
)
`

type InsertLottieSectionParams struct {
	SectionID   int32          `json:"sectionId"`
	Caption     sql.NullString `json:"caption"`
	Description sql.NullString `json:"description"`
	Width       sql.NullInt32  `json:"width"`
	Height      sql.NullInt32  `json:"height"`
	ObjectKey   uuid.NullUUID  `json:"objectKey"`
	MediaExt    sql.NullString `json:"mediaExt"`
	AltText     sql.NullString `json:"altText"`
	FallbackUrl sql.NullString `json:"fallbackUrl"`
	Autoplay    bool           `json:"autoplay"`
	Loop        bool           `json:"loop"`
	Speed       float64        `json:"speed"`
}

func (q *Queries) InsertLottieSection(ctx context.Context, arg InsertLottieSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertLottieSection,
		arg.SectionID,
		arg.Caption,
		arg.Description,
		arg.Width,
		arg.Height,
		arg.ObjectKey,
		arg.MediaExt,
		arg.AltText,
		arg.FallbackUrl,
		arg.Autoplay,
		arg.Loop,
		arg.Speed,
	)
	return err
}

const insertMarkdownSection = `-- name: InsertMarkdownSection :exec
INSERT INTO
    markdown_sections (section_id, markdown, object_key, media_ext)
VALUES ($1, $2, $3, $4)
`

type InsertMarkdownSectionParams struct {
	SectionID int32          `json:"sectionId"`
	Markdown  string         `json:"markdown"`
	ObjectKey uuid.NullUUID  `json:"objectKey"`
	MediaExt  sql.NullString `json:"mediaExt"`
}

func (q *Queries) InsertMarkdownSection(ctx context.Context, arg InsertMarkdownSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertMarkdownSection,
		arg.SectionID,
		arg.Markdown,
		arg.ObjectKey,
		arg.MediaExt,
	)
	return err
}

const insertModule = `-- name: InsertModule :one
INSERT INTO
    modules (
        folder_object_key,
        img_key,
        media_ext,
        module_number,
        unit_id,
        name,
        description
    )
VALUES (COALESCE($1::UUID, NULL), COALESCE($2::UUID, NULL), COALESCE($3::text, ''), $4, $5, $6, $7) RETURNING id, folder_object_key, created_at, updated_at, img_key, media_ext, draft, module_number, unit_id, name, description
`

type InsertModuleParams struct {
	FolderObjectKey uuid.UUID `json:"folderObjectKey"`
	ImgKey          uuid.UUID `json:"imgKey"`
	MediaExt        string    `json:"mediaExt"`
	ModuleNumber    int32     `json:"moduleNumber"`
	UnitID          int32     `json:"unitId"`
	Name            string    `json:"name"`
	Description     string    `json:"description"`
}

func (q *Queries) InsertModule(ctx context.Context, arg InsertModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, insertModule,
		arg.FolderObjectKey,
		arg.ImgKey,
		arg.MediaExt,
		arg.ModuleNumber,
		arg.UnitID,
		arg.Name,
		arg.Description,
	)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.FolderObjectKey,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImgKey,
		&i.MediaExt,
		&i.Draft,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const insertQuestion = `-- name: InsertQuestion :one
INSERT INTO
    questions (
        type,
        question,
        difficulty_level
    )
VALUES ($1, $2, $3) RETURNING id, created_at, updated_at, type, question, difficulty_level
`

type InsertQuestionParams struct {
	Type            string              `json:"type"`
	Question        string              `json:"question"`
	DifficultyLevel NullDifficultyLevel `json:"difficultyLevel"`
}

func (q *Queries) InsertQuestion(ctx context.Context, arg InsertQuestionParams) (Question, error) {
	row := q.db.QueryRowContext(ctx, insertQuestion, arg.Type, arg.Question, arg.DifficultyLevel)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.Question,
		&i.DifficultyLevel,
	)
	return i, err
}

const insertQuestionOption = `-- name: InsertQuestionOption :exec
INSERT INTO
    question_options (
        question_id,
        content,
        is_correct
    )
VALUES ($1, $2, $3)
`

type InsertQuestionOptionParams struct {
	QuestionID int32  `json:"questionId"`
	Content    string `json:"content"`
	IsCorrect  bool   `json:"isCorrect"`
}

func (q *Queries) InsertQuestionOption(ctx context.Context, arg InsertQuestionOptionParams) error {
	_, err := q.db.ExecContext(ctx, insertQuestionOption, arg.QuestionID, arg.Content, arg.IsCorrect)
	return err
}

const insertQuestionSection = `-- name: InsertQuestionSection :exec
INSERT INTO
    question_sections (section_id, question_id, object_key, media_ext)
VALUES ($1, $2, $3, $4)
`

type InsertQuestionSectionParams struct {
	SectionID  int32          `json:"sectionId"`
	QuestionID int32          `json:"questionId"`
	ObjectKey  uuid.NullUUID  `json:"objectKey"`
	MediaExt   sql.NullString `json:"mediaExt"`
}

func (q *Queries) InsertQuestionSection(ctx context.Context, arg InsertQuestionSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertQuestionSection,
		arg.SectionID,
		arg.QuestionID,
		arg.ObjectKey,
		arg.MediaExt,
	)
	return err
}

const insertQuestionTag = `-- name: InsertQuestionTag :exec
INSERT INTO question_tags (question_id, tag_id) VALUES ($1, $2)
`

type InsertQuestionTagParams struct {
	QuestionID int32 `json:"questionId"`
	TagID      int32 `json:"tagId"`
}

func (q *Queries) InsertQuestionTag(ctx context.Context, arg InsertQuestionTagParams) error {
	_, err := q.db.ExecContext(ctx, insertQuestionTag, arg.QuestionID, arg.TagID)
	return err
}

const insertSection = `-- name: InsertSection :one
INSERT INTO
    sections (module_id, type, position)
VALUES ($1, $2::section_type, $3) RETURNING id, created_at, updated_at, module_id, type, position
`

type InsertSectionParams struct {
	ModuleID    int32       `json:"moduleId"`
	SectionType SectionType `json:"sectionType"`
	Position    int32       `json:"position"`
}

func (q *Queries) InsertSection(ctx context.Context, arg InsertSectionParams) (Section, error) {
	row := q.db.QueryRowContext(ctx, insertSection, arg.ModuleID, arg.SectionType, arg.Position)
	var i Section
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ModuleID,
		&i.Type,
		&i.Position,
	)
	return i, err
}

const insertTag = `-- name: InsertTag :one
INSERT INTO
    tags (name)
VALUES ($1) ON CONFLICT (name) DO
UPDATE
SET
    name = EXCLUDED.name RETURNING id
`

func (q *Queries) InsertTag(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertTag, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertVideoSection = `-- name: InsertVideoSection :exec
INSERT INTO video_sections (section_id, url, object_key, media_ext) VALUES ($1, $2, $3, $4)
`

type InsertVideoSectionParams struct {
	SectionID int32          `json:"sectionId"`
	Url       string         `json:"url"`
	ObjectKey uuid.NullUUID  `json:"objectKey"`
	MediaExt  sql.NullString `json:"mediaExt"`
}

func (q *Queries) InsertVideoSection(ctx context.Context, arg InsertVideoSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertVideoSection,
		arg.SectionID,
		arg.Url,
		arg.ObjectKey,
		arg.MediaExt,
	)
	return err
}

const isModuleFurtherThan = `-- name: IsModuleFurtherThan :one
SELECT EXISTS (
  SELECT 1
  FROM modules m1
  JOIN units u1 ON m1.unit_id = u1.id
  JOIN modules m2 ON m2.id = $1::int
  JOIN units u2 ON m2.unit_id = u2.id
  WHERE m1.id = $2::int
    AND (
      u1.unit_number > u2.unit_number
      OR (u1.unit_number = u2.unit_number AND m1.module_number > m2.module_number)
    )
) as is_further
`

type IsModuleFurtherThanParams struct {
	FurthestModuleID int32 `json:"furthestModuleId"`
	ModuleID         int32 `json:"moduleId"`
}

func (q *Queries) IsModuleFurtherThan(ctx context.Context, arg IsModuleFurtherThanParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isModuleFurtherThan, arg.FurthestModuleID, arg.ModuleID)
	var is_further bool
	err := row.Scan(&is_further)
	return is_further, err
}

const updateModule = `-- name: UpdateModule :one
UPDATE modules
SET
    name = COALESCE(NULLIF($1::text, ''), name),
    description = COALESCE(NULLIF($2::text, ''), description),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3::int
RETURNING id, folder_object_key, created_at, updated_at, img_key, media_ext, draft, module_number, unit_id, name, description
`

type UpdateModuleParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ModuleID    int32  `json:"moduleId"`
}

func (q *Queries) UpdateModule(ctx context.Context, arg UpdateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, updateModule, arg.Name, arg.Description, arg.ModuleID)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.FolderObjectKey,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImgKey,
		&i.MediaExt,
		&i.Draft,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const upsertQuestionAnswer = `-- name: UpsertQuestionAnswer :exec
INSERT INTO
    user_question_answers (
        user_module_progress_id,
        question_id,
        option_id,
        is_correct,
        answered_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        COALESCE($5, NOW())
    ) ON CONFLICT (
        user_module_progress_id,
        question_id
    ) DO
UPDATE
SET
    option_id = EXCLUDED.option_id,
    is_correct = EXCLUDED.is_correct,
    answered_at = EXCLUDED.answered_at,
    updated_at = NOW()
`

type UpsertQuestionAnswerParams struct {
	UserModuleProgressID int32       `json:"userModuleProgressId"`
	QuestionID           int32       `json:"questionId"`
	OptionID             int32       `json:"optionId"`
	IsCorrect            bool        `json:"isCorrect"`
	Column5              interface{} `json:"column5"`
}

func (q *Queries) UpsertQuestionAnswer(ctx context.Context, arg UpsertQuestionAnswerParams) error {
	_, err := q.db.ExecContext(ctx, upsertQuestionAnswer,
		arg.UserModuleProgressID,
		arg.QuestionID,
		arg.OptionID,
		arg.IsCorrect,
		arg.Column5,
	)
	return err
}

const upsertSectionProgress = `-- name: UpsertSectionProgress :exec
INSERT INTO
    user_section_progress (
        user_id,
        module_id,
        section_id,
        has_seen,
        seen_at
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (user_id, section_id) DO
UPDATE
SET
    has_seen = EXCLUDED.has_seen,
    seen_at = EXCLUDED.seen_at
`

type UpsertSectionProgressParams struct {
	UserID    int32        `json:"userId"`
	ModuleID  int32        `json:"moduleId"`
	SectionID int32        `json:"sectionId"`
	HasSeen   bool         `json:"hasSeen"`
	SeenAt    sql.NullTime `json:"seenAt"`
}

func (q *Queries) UpsertSectionProgress(ctx context.Context, arg UpsertSectionProgressParams) error {
	_, err := q.db.ExecContext(ctx, upsertSectionProgress,
		arg.UserID,
		arg.ModuleID,
		arg.SectionID,
		arg.HasSeen,
		arg.SeenAt,
	)
	return err
}

const upsertUserCourse = `-- name: UpsertUserCourse :exec
INSERT INTO
    user_courses (user_id, course_id, progress)
VALUES ($1, $2, $3) ON CONFLICT (user_id, course_id) DO
UPDATE
SET
    progress = EXCLUDED.progress,
    updated_at = NOW()
`

type UpsertUserCourseParams struct {
	UserID   int32   `json:"userId"`
	CourseID int32   `json:"courseId"`
	Progress float64 `json:"progress"`
}

func (q *Queries) UpsertUserCourse(ctx context.Context, arg UpsertUserCourseParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserCourse, arg.UserID, arg.CourseID, arg.Progress)
	return err
}

const upsertUserModuleProgress = `-- name: UpsertUserModuleProgress :one
INSERT INTO user_module_progress (
    user_id,
    module_id,
    status,
    progress
)
VALUES (
    $1,
    $2,
    'in_progress',
    COALESCE($3, 0)
)
ON CONFLICT (user_id, module_id)
DO UPDATE SET
    progress = COALESCE($3, user_module_progress.progress),
    status = CASE
        WHEN $3 >= 100 THEN 'completed'::module_progress_status
        ELSE 'in_progress'::module_progress_status
    END,
    completed_at = CASE
        WHEN $3 >= 100 THEN NOW()
        ELSE NULL
    END,
    updated_at = NOW()
RETURNING id
`

type UpsertUserModuleProgressParams struct {
	UserID   int32       `json:"userId"`
	ModuleID int32       `json:"moduleId"`
	Column3  interface{} `json:"column3"`
}

func (q *Queries) UpsertUserModuleProgress(ctx context.Context, arg UpsertUserModuleProgressParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertUserModuleProgress, arg.UserID, arg.ModuleID, arg.Column3)
	var id int32
	err := row.Scan(&id)
	return id, err
}
