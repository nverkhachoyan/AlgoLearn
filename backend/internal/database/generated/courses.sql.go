// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: courses.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const deleteCourse = `-- name: DeleteCourse :exec
DELETE FROM courses WHERE id = $1::int
`

func (q *Queries) DeleteCourse(ctx context.Context, courseID int32) error {
	_, err := q.db.ExecContext(ctx, deleteCourse, courseID)
	return err
}

const deleteCourseProgress = `-- name: DeleteCourseProgress :exec
DELETE FROM user_courses WHERE user_id = $1::int AND course_id = $2::int
`

type DeleteCourseProgressParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

func (q *Queries) DeleteCourseProgress(ctx context.Context, arg DeleteCourseProgressParams) error {
	_, err := q.db.ExecContext(ctx, deleteCourseProgress, arg.UserID, arg.CourseID)
	return err
}

const getCourse = `-- name: GetCourse :one
SELECT
    id,
    created_at,
    updated_at,
    name,
    description,
    requirements,
    what_you_learn,
    background_color,
    icon_url,
    duration,
    difficulty_level,
    rating
FROM courses
WHERE
    id = $1::int
`

func (q *Queries) GetCourse(ctx context.Context, courseID int32) (Course, error) {
	row := q.db.QueryRowContext(ctx, getCourse, courseID)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Requirements,
		&i.WhatYouLearn,
		&i.BackgroundColor,
		&i.IconUrl,
		&i.Duration,
		&i.DifficultyLevel,
		&i.Rating,
	)
	return i, err
}

const getCourseAuthors = `-- name: GetCourseAuthors :many
SELECT a.id, a.name
FROM authors a
    JOIN course_authors ca ON ca.author_id = a.id
WHERE
    ca.course_id = $1::int
`

func (q *Queries) GetCourseAuthors(ctx context.Context, courseID int32) ([]Author, error) {
	rows, err := q.db.QueryContext(ctx, getCourseAuthors, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Author{}
	for rows.Next() {
		var i Author
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseByID = `-- name: GetCourseByID :one
SELECT
    id,
    created_at,
    updated_at,
    name,
    description,
    requirements,
    what_you_learn,
    background_color,
    icon_url,
    duration,
    difficulty_level,
    rating
FROM courses
WHERE
    id = $1::int
`

func (q *Queries) GetCourseByID(ctx context.Context, courseID int32) (Course, error) {
	row := q.db.QueryRowContext(ctx, getCourseByID, courseID)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Requirements,
		&i.WhatYouLearn,
		&i.BackgroundColor,
		&i.IconUrl,
		&i.Duration,
		&i.DifficultyLevel,
		&i.Rating,
	)
	return i, err
}

const getCourseProgressFullBase = `-- name: GetCourseProgressFullBase :one
SELECT
    c.id,
    c.created_at,
    c.updated_at,
    c.name,
    c.description,
    c.requirements,
    c.what_you_learn,
    c.background_color,
    c.icon_url,
    c.duration,
    c.difficulty_level,
    c.rating,
    u.id as current_unit_id,
    u.created_at as unit_created_at,
    u.updated_at as unit_updated_at,
    u.unit_number,
    u.name as unit_name,
    u.description as unit_description,
    m.id as current_module_id,
    m.created_at as module_created_at,
    m.updated_at as module_updated_at,
    m.module_number,
    m.unit_id as module_unit_id,
    m.name as module_name,
    m.description as module_description,
    ump.progress as module_progress,
    ump.status as module_status
FROM courses c
    JOIN user_courses uc ON uc.course_id = c.id AND uc.user_id = $1::int
    LEFT JOIN units u ON u.id = uc.current_unit_id
    LEFT JOIN modules m ON m.id = uc.current_module_id
    LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
WHERE c.id = $2::int
`

type GetCourseProgressFullBaseParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

type GetCourseProgressFullBaseRow struct {
	ID                int32                    `json:"id"`
	CreatedAt         time.Time                `json:"createdAt"`
	UpdatedAt         time.Time                `json:"updatedAt"`
	Name              string                   `json:"name"`
	Description       string                   `json:"description"`
	Requirements      sql.NullString           `json:"requirements"`
	WhatYouLearn      sql.NullString           `json:"whatYouLearn"`
	BackgroundColor   sql.NullString           `json:"backgroundColor"`
	IconUrl           sql.NullString           `json:"iconUrl"`
	Duration          sql.NullInt32            `json:"duration"`
	DifficultyLevel   NullDifficultyLevel      `json:"difficultyLevel"`
	Rating            sql.NullFloat64          `json:"rating"`
	CurrentUnitID     sql.NullInt32            `json:"currentUnitId"`
	UnitCreatedAt     sql.NullTime             `json:"unitCreatedAt"`
	UnitUpdatedAt     sql.NullTime             `json:"unitUpdatedAt"`
	UnitNumber        sql.NullInt32            `json:"unitNumber"`
	UnitName          sql.NullString           `json:"unitName"`
	UnitDescription   sql.NullString           `json:"unitDescription"`
	CurrentModuleID   sql.NullInt32            `json:"currentModuleId"`
	ModuleCreatedAt   sql.NullTime             `json:"moduleCreatedAt"`
	ModuleUpdatedAt   sql.NullTime             `json:"moduleUpdatedAt"`
	ModuleNumber      sql.NullInt32            `json:"moduleNumber"`
	ModuleUnitID      sql.NullInt32            `json:"moduleUnitId"`
	ModuleName        sql.NullString           `json:"moduleName"`
	ModuleDescription sql.NullString           `json:"moduleDescription"`
	ModuleProgress    sql.NullFloat64          `json:"moduleProgress"`
	ModuleStatus      NullModuleProgressStatus `json:"moduleStatus"`
}

func (q *Queries) GetCourseProgressFullBase(ctx context.Context, arg GetCourseProgressFullBaseParams) (GetCourseProgressFullBaseRow, error) {
	row := q.db.QueryRowContext(ctx, getCourseProgressFullBase, arg.UserID, arg.CourseID)
	var i GetCourseProgressFullBaseRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Requirements,
		&i.WhatYouLearn,
		&i.BackgroundColor,
		&i.IconUrl,
		&i.Duration,
		&i.DifficultyLevel,
		&i.Rating,
		&i.CurrentUnitID,
		&i.UnitCreatedAt,
		&i.UnitUpdatedAt,
		&i.UnitNumber,
		&i.UnitName,
		&i.UnitDescription,
		&i.CurrentModuleID,
		&i.ModuleCreatedAt,
		&i.ModuleUpdatedAt,
		&i.ModuleNumber,
		&i.ModuleUnitID,
		&i.ModuleName,
		&i.ModuleDescription,
		&i.ModuleProgress,
		&i.ModuleStatus,
	)
	return i, err
}

const getCourseProgressSummaryBase = `-- name: GetCourseProgressSummaryBase :one
SELECT
    c.id,
    c.created_at,
    c.updated_at,
    c.name,
    c.description,
    c.requirements,
    c.what_you_learn,
    c.background_color,
    c.icon_url,
    c.difficulty_level,
    c.duration,
    c.rating,
    u.id as current_unit_id,
    u.created_at as unit_created_at,
    u.updated_at as unit_updated_at,
    u.unit_number,
    u.name as unit_name,
    u.description as unit_description,
    m.id as current_module_id,
    m.created_at as module_created_at,
    m.updated_at as module_updated_at,
    m.module_number,
    m.unit_id as module_unit_id,
    m.name as module_name,
    m.description as module_description,
    ump.progress as module_progress,
    ump.status as module_status
FROM
    courses c
    JOIN user_courses uc ON uc.course_id = c.id
    AND uc.user_id = $1::int
    LEFT JOIN units u ON u.id = uc.current_unit_id
    LEFT JOIN modules m ON m.id = uc.current_module_id
    LEFT JOIN user_module_progress ump ON ump.module_id = m.id
    AND ump.user_id = $1::int
WHERE
    c.id = $2::int
`

type GetCourseProgressSummaryBaseParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

type GetCourseProgressSummaryBaseRow struct {
	ID                int32                    `json:"id"`
	CreatedAt         time.Time                `json:"createdAt"`
	UpdatedAt         time.Time                `json:"updatedAt"`
	Name              string                   `json:"name"`
	Description       string                   `json:"description"`
	Requirements      sql.NullString           `json:"requirements"`
	WhatYouLearn      sql.NullString           `json:"whatYouLearn"`
	BackgroundColor   sql.NullString           `json:"backgroundColor"`
	IconUrl           sql.NullString           `json:"iconUrl"`
	DifficultyLevel   NullDifficultyLevel      `json:"difficultyLevel"`
	Duration          sql.NullInt32            `json:"duration"`
	Rating            sql.NullFloat64          `json:"rating"`
	CurrentUnitID     sql.NullInt32            `json:"currentUnitId"`
	UnitCreatedAt     sql.NullTime             `json:"unitCreatedAt"`
	UnitUpdatedAt     sql.NullTime             `json:"unitUpdatedAt"`
	UnitNumber        sql.NullInt32            `json:"unitNumber"`
	UnitName          sql.NullString           `json:"unitName"`
	UnitDescription   sql.NullString           `json:"unitDescription"`
	CurrentModuleID   sql.NullInt32            `json:"currentModuleId"`
	ModuleCreatedAt   sql.NullTime             `json:"moduleCreatedAt"`
	ModuleUpdatedAt   sql.NullTime             `json:"moduleUpdatedAt"`
	ModuleNumber      sql.NullInt32            `json:"moduleNumber"`
	ModuleUnitID      sql.NullInt32            `json:"moduleUnitId"`
	ModuleName        sql.NullString           `json:"moduleName"`
	ModuleDescription sql.NullString           `json:"moduleDescription"`
	ModuleProgress    sql.NullFloat64          `json:"moduleProgress"`
	ModuleStatus      NullModuleProgressStatus `json:"moduleStatus"`
}

func (q *Queries) GetCourseProgressSummaryBase(ctx context.Context, arg GetCourseProgressSummaryBaseParams) (GetCourseProgressSummaryBaseRow, error) {
	row := q.db.QueryRowContext(ctx, getCourseProgressSummaryBase, arg.UserID, arg.CourseID)
	var i GetCourseProgressSummaryBaseRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Requirements,
		&i.WhatYouLearn,
		&i.BackgroundColor,
		&i.IconUrl,
		&i.DifficultyLevel,
		&i.Duration,
		&i.Rating,
		&i.CurrentUnitID,
		&i.UnitCreatedAt,
		&i.UnitUpdatedAt,
		&i.UnitNumber,
		&i.UnitName,
		&i.UnitDescription,
		&i.CurrentModuleID,
		&i.ModuleCreatedAt,
		&i.ModuleUpdatedAt,
		&i.ModuleNumber,
		&i.ModuleUnitID,
		&i.ModuleName,
		&i.ModuleDescription,
		&i.ModuleProgress,
		&i.ModuleStatus,
	)
	return i, err
}

const getCourseTags = `-- name: GetCourseTags :many
SELECT t.id, t.name
FROM tags t
    JOIN course_tags ct ON ct.tag_id = t.id
WHERE
    ct.course_id = $1::int
`

func (q *Queries) GetCourseTags(ctx context.Context, courseID int32) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getCourseTags, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseUnits = `-- name: GetCourseUnits :many
SELECT
    id,
    created_at,
    updated_at,
    unit_number,
    course_id,
    name,
    description
FROM units
WHERE
    course_id = $1::int
ORDER BY unit_number
`

func (q *Queries) GetCourseUnits(ctx context.Context, courseID int32) ([]Unit, error) {
	rows, err := q.db.QueryContext(ctx, getCourseUnits, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Unit{}
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnitNumber,
			&i.CourseID,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesProgressSummary = `-- name: GetCoursesProgressSummary :many
SELECT
    c.id,
    c.created_at,
    c.updated_at,
    c.name,
    c.description,
    c.requirements,
    c.what_you_learn,
    c.background_color,
    c.icon_url,
    c.duration,
    c.difficulty_level,
    c.rating,
    u.id as current_unit_id,
    u.created_at as unit_created_at,
    u.updated_at as unit_updated_at,
    u.unit_number,
    u.name as unit_name,
    u.description as unit_description,
    m.id as current_module_id,
    m.created_at as module_created_at,
    m.updated_at as module_updated_at,
    m.module_number,
    m.unit_id as module_unit_id,
    m.name as module_name,
    m.description as module_description,
    ump.progress as module_progress,
    ump.status as module_status,
    COUNT(*) OVER() as total_count
FROM
    courses c
    LEFT JOIN user_courses uc ON uc.course_id = c.id AND uc.user_id = $1::int
    LEFT JOIN units u ON u.id = uc.current_unit_id
    LEFT JOIN modules m ON m.id = uc.current_module_id
    LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
WHERE
    uc.user_id = $1::int
ORDER BY c.id, uc.updated_at DESC NULLS LAST
LIMIT $3::int
OFFSET $2::int
`

type GetCoursesProgressSummaryParams struct {
	UserID     int32 `json:"userId"`
	PageOffset int32 `json:"pageOffset"`
	PageLimit  int32 `json:"pageLimit"`
}

type GetCoursesProgressSummaryRow struct {
	ID                int32                    `json:"id"`
	CreatedAt         time.Time                `json:"createdAt"`
	UpdatedAt         time.Time                `json:"updatedAt"`
	Name              string                   `json:"name"`
	Description       string                   `json:"description"`
	Requirements      sql.NullString           `json:"requirements"`
	WhatYouLearn      sql.NullString           `json:"whatYouLearn"`
	BackgroundColor   sql.NullString           `json:"backgroundColor"`
	IconUrl           sql.NullString           `json:"iconUrl"`
	Duration          sql.NullInt32            `json:"duration"`
	DifficultyLevel   NullDifficultyLevel      `json:"difficultyLevel"`
	Rating            sql.NullFloat64          `json:"rating"`
	CurrentUnitID     sql.NullInt32            `json:"currentUnitId"`
	UnitCreatedAt     sql.NullTime             `json:"unitCreatedAt"`
	UnitUpdatedAt     sql.NullTime             `json:"unitUpdatedAt"`
	UnitNumber        sql.NullInt32            `json:"unitNumber"`
	UnitName          sql.NullString           `json:"unitName"`
	UnitDescription   sql.NullString           `json:"unitDescription"`
	CurrentModuleID   sql.NullInt32            `json:"currentModuleId"`
	ModuleCreatedAt   sql.NullTime             `json:"moduleCreatedAt"`
	ModuleUpdatedAt   sql.NullTime             `json:"moduleUpdatedAt"`
	ModuleNumber      sql.NullInt32            `json:"moduleNumber"`
	ModuleUnitID      sql.NullInt32            `json:"moduleUnitId"`
	ModuleName        sql.NullString           `json:"moduleName"`
	ModuleDescription sql.NullString           `json:"moduleDescription"`
	ModuleProgress    sql.NullFloat64          `json:"moduleProgress"`
	ModuleStatus      NullModuleProgressStatus `json:"moduleStatus"`
	TotalCount        int64                    `json:"totalCount"`
}

func (q *Queries) GetCoursesProgressSummary(ctx context.Context, arg GetCoursesProgressSummaryParams) ([]GetCoursesProgressSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getCoursesProgressSummary, arg.UserID, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoursesProgressSummaryRow{}
	for rows.Next() {
		var i GetCoursesProgressSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Requirements,
			&i.WhatYouLearn,
			&i.BackgroundColor,
			&i.IconUrl,
			&i.Duration,
			&i.DifficultyLevel,
			&i.Rating,
			&i.CurrentUnitID,
			&i.UnitCreatedAt,
			&i.UnitUpdatedAt,
			&i.UnitNumber,
			&i.UnitName,
			&i.UnitDescription,
			&i.CurrentModuleID,
			&i.ModuleCreatedAt,
			&i.ModuleUpdatedAt,
			&i.ModuleNumber,
			&i.ModuleUnitID,
			&i.ModuleName,
			&i.ModuleDescription,
			&i.ModuleProgress,
			&i.ModuleStatus,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstUnitAndModule = `-- name: GetFirstUnitAndModule :one
SELECT u.id as unit_id, m.id as module_id
FROM units u
JOIN modules m ON m.unit_id = u.id
WHERE u.course_id = $1::int
LIMIT 1
`

type GetFirstUnitAndModuleRow struct {
	UnitID   int32 `json:"unitId"`
	ModuleID int32 `json:"moduleId"`
}

func (q *Queries) GetFirstUnitAndModule(ctx context.Context, courseID int32) (GetFirstUnitAndModuleRow, error) {
	row := q.db.QueryRowContext(ctx, getFirstUnitAndModule, courseID)
	var i GetFirstUnitAndModuleRow
	err := row.Scan(&i.UnitID, &i.ModuleID)
	return i, err
}

const getModuleProgress = `-- name: GetModuleProgress :one
SELECT progress, status
FROM user_module_progress
WHERE
    user_id = $1::int
    AND module_id = $2::int
`

type GetModuleProgressParams struct {
	UserID   int32 `json:"userId"`
	ModuleID int32 `json:"moduleId"`
}

type GetModuleProgressRow struct {
	Progress float64              `json:"progress"`
	Status   ModuleProgressStatus `json:"status"`
}

func (q *Queries) GetModuleProgress(ctx context.Context, arg GetModuleProgressParams) (GetModuleProgressRow, error) {
	row := q.db.QueryRowContext(ctx, getModuleProgress, arg.UserID, arg.ModuleID)
	var i GetModuleProgressRow
	err := row.Scan(&i.Progress, &i.Status)
	return i, err
}

const getModuleProgressByUnit = `-- name: GetModuleProgressByUnit :many
SELECT m.id, m.created_at, m.updated_at, m.module_number, m.unit_id, m.name, m.description, ump.progress, ump.status
FROM
    modules m
    LEFT JOIN user_module_progress ump ON ump.module_id = m.id
    AND ump.user_id = $1::int
WHERE
    m.unit_id = $2::int
ORDER BY m.module_number
`

type GetModuleProgressByUnitParams struct {
	UserID int32 `json:"userId"`
	UnitID int32 `json:"unitId"`
}

type GetModuleProgressByUnitRow struct {
	ID           int32                    `json:"id"`
	CreatedAt    time.Time                `json:"createdAt"`
	UpdatedAt    time.Time                `json:"updatedAt"`
	ModuleNumber int32                    `json:"moduleNumber"`
	UnitID       int32                    `json:"unitId"`
	Name         string                   `json:"name"`
	Description  string                   `json:"description"`
	Progress     sql.NullFloat64          `json:"progress"`
	Status       NullModuleProgressStatus `json:"status"`
}

func (q *Queries) GetModuleProgressByUnit(ctx context.Context, arg GetModuleProgressByUnitParams) ([]GetModuleProgressByUnitRow, error) {
	rows, err := q.db.QueryContext(ctx, getModuleProgressByUnit, arg.UserID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModuleProgressByUnitRow{}
	for rows.Next() {
		var i GetModuleProgressByUnitRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ModuleNumber,
			&i.UnitID,
			&i.Name,
			&i.Description,
			&i.Progress,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModuleProgressWithSections = `-- name: GetModuleProgressWithSections :many
SELECT 
    m.id, m.created_at, m.updated_at, m.module_number, m.unit_id, m.name, m.description,
    ump.progress, ump.status,
    s.id as section_id, s.created_at as section_created_at, s.updated_at as section_updated_at,
    s.type as section_type, s.position as section_position,
    usp.seen_at, usp.started_at, usp.completed_at, usp.has_seen
FROM modules m
    LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
    LEFT JOIN sections s ON s.module_id = m.id
    LEFT JOIN user_section_progress usp ON usp.section_id = s.id AND usp.user_id = $1::int
WHERE m.unit_id = $2::int
ORDER BY m.module_number, s.position
`

type GetModuleProgressWithSectionsParams struct {
	UserID int32 `json:"userId"`
	UnitID int32 `json:"unitId"`
}

type GetModuleProgressWithSectionsRow struct {
	ID               int32                    `json:"id"`
	CreatedAt        time.Time                `json:"createdAt"`
	UpdatedAt        time.Time                `json:"updatedAt"`
	ModuleNumber     int32                    `json:"moduleNumber"`
	UnitID           int32                    `json:"unitId"`
	Name             string                   `json:"name"`
	Description      string                   `json:"description"`
	Progress         sql.NullFloat64          `json:"progress"`
	Status           NullModuleProgressStatus `json:"status"`
	SectionID        sql.NullInt32            `json:"sectionId"`
	SectionCreatedAt sql.NullTime             `json:"sectionCreatedAt"`
	SectionUpdatedAt sql.NullTime             `json:"sectionUpdatedAt"`
	SectionType      sql.NullString           `json:"sectionType"`
	SectionPosition  sql.NullInt32            `json:"sectionPosition"`
	SeenAt           sql.NullTime             `json:"seenAt"`
	StartedAt        sql.NullTime             `json:"startedAt"`
	CompletedAt      sql.NullTime             `json:"completedAt"`
	HasSeen          sql.NullBool             `json:"hasSeen"`
}

func (q *Queries) GetModuleProgressWithSections(ctx context.Context, arg GetModuleProgressWithSectionsParams) ([]GetModuleProgressWithSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getModuleProgressWithSections, arg.UserID, arg.UnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModuleProgressWithSectionsRow{}
	for rows.Next() {
		var i GetModuleProgressWithSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ModuleNumber,
			&i.UnitID,
			&i.Name,
			&i.Description,
			&i.Progress,
			&i.Status,
			&i.SectionID,
			&i.SectionCreatedAt,
			&i.SectionUpdatedAt,
			&i.SectionType,
			&i.SectionPosition,
			&i.SeenAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.HasSeen,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModuleSections = `-- name: GetModuleSections :many
SELECT
    id,
    created_at,
    updated_at,
    type,
    position,
    module_id
FROM sections
WHERE
    module_id = $1::int
ORDER BY position
`

type GetModuleSectionsRow struct {
	ID        int32     `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	Type      string    `json:"type"`
	Position  int32     `json:"position"`
	ModuleID  int32     `json:"moduleId"`
}

func (q *Queries) GetModuleSections(ctx context.Context, moduleID int32) ([]GetModuleSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getModuleSections, moduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModuleSectionsRow{}
	for rows.Next() {
		var i GetModuleSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Position,
			&i.ModuleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModuleSectionsWithProgress = `-- name: GetModuleSectionsWithProgress :many
SELECT 
    s.id, 
    s.created_at, 
    s.updated_at, 
    s.type, 
    s.position, 
    s.module_id, 
    usp.seen_at, 
    usp.started_at, 
    usp.completed_at, 
    usp.has_seen
FROM
    sections s
    LEFT JOIN user_section_progress usp ON usp.section_id = s.id
    AND usp.user_id = $1::int
WHERE
    s.module_id = $2::int
ORDER BY s.position
`

type GetModuleSectionsWithProgressParams struct {
	UserID   int32 `json:"userId"`
	ModuleID int32 `json:"moduleId"`
}

type GetModuleSectionsWithProgressRow struct {
	ID          int32        `json:"id"`
	CreatedAt   time.Time    `json:"createdAt"`
	UpdatedAt   time.Time    `json:"updatedAt"`
	Type        string       `json:"type"`
	Position    int32        `json:"position"`
	ModuleID    int32        `json:"moduleId"`
	SeenAt      sql.NullTime `json:"seenAt"`
	StartedAt   sql.NullTime `json:"startedAt"`
	CompletedAt sql.NullTime `json:"completedAt"`
	HasSeen     sql.NullBool `json:"hasSeen"`
}

func (q *Queries) GetModuleSectionsWithProgress(ctx context.Context, arg GetModuleSectionsWithProgressParams) ([]GetModuleSectionsWithProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, getModuleSectionsWithProgress, arg.UserID, arg.ModuleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModuleSectionsWithProgressRow{}
	for rows.Next() {
		var i GetModuleSectionsWithProgressRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Position,
			&i.ModuleID,
			&i.SeenAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.HasSeen,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionOptions = `-- name: GetQuestionOptions :many
SELECT id, content, is_correct
FROM question_options
WHERE
    question_id = $1::int
`

type GetQuestionOptionsRow struct {
	ID        int32  `json:"id"`
	Content   string `json:"content"`
	IsCorrect bool   `json:"isCorrect"`
}

func (q *Queries) GetQuestionOptions(ctx context.Context, questionID int32) ([]GetQuestionOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getQuestionOptions, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionOptionsRow{}
	for rows.Next() {
		var i GetQuestionOptionsRow
		if err := rows.Scan(&i.ID, &i.Content, &i.IsCorrect); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionSection = `-- name: GetQuestionSection :one
SELECT 
    q.id,
    q.question,
    q.type,
    COALESCE(
        json_agg(
            json_build_object(
                'id', qo.id,
                'content', qo.content,
                'is_correct', qo.is_correct
            ) ORDER BY qo.id
        ),
        '[]'::json
    ) as question_options
FROM question_sections qs
JOIN questions q ON q.id = qs.question_id
LEFT JOIN question_options qo ON qo.question_id = q.id
WHERE qs.section_id = $1::int
GROUP BY q.id, q.question, q.type
`

type GetQuestionSectionRow struct {
	ID              int32       `json:"id"`
	Question        string      `json:"question"`
	Type            string      `json:"type"`
	QuestionOptions interface{} `json:"questionOptions"`
}

func (q *Queries) GetQuestionSection(ctx context.Context, sectionID int32) (GetQuestionSectionRow, error) {
	row := q.db.QueryRowContext(ctx, getQuestionSection, sectionID)
	var i GetQuestionSectionRow
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.Type,
		&i.QuestionOptions,
	)
	return i, err
}

const getQuestionSectionContent = `-- name: GetQuestionSectionContent :one
SELECT 
    q.id as question_id,
    q.question,
    q.type as question_type,
    COALESCE(
        json_agg(
            json_build_object(
                'id', qo.id,
                'content', qo.content,
                'is_correct', qo.is_correct
            ) ORDER BY qo.id
        ),
        '[]'::json
    ) as options
FROM question_sections qs
JOIN questions q ON q.id = qs.question_id
LEFT JOIN question_options qo ON qo.question_id = q.id
WHERE qs.section_id = $1::int
GROUP BY q.id, q.question, q.type
`

type GetQuestionSectionContentRow struct {
	QuestionID   int32       `json:"questionId"`
	Question     string      `json:"question"`
	QuestionType string      `json:"questionType"`
	Options      interface{} `json:"options"`
}

func (q *Queries) GetQuestionSectionContent(ctx context.Context, sectionID int32) (GetQuestionSectionContentRow, error) {
	row := q.db.QueryRowContext(ctx, getQuestionSectionContent, sectionID)
	var i GetQuestionSectionContentRow
	err := row.Scan(
		&i.QuestionID,
		&i.Question,
		&i.QuestionType,
		&i.Options,
	)
	return i, err
}

const getSectionContent = `-- name: GetSectionContent :one
SELECT 
    CASE s.type
        WHEN 'text' THEN (
            SELECT jsonb_build_object('text', text_content)
            FROM text_sections
            WHERE section_id = s.id
        )
        WHEN 'video' THEN (
            SELECT jsonb_build_object('url', url)
            FROM video_sections
            WHERE section_id = s.id
        )
        WHEN 'question' THEN (
            SELECT jsonb_build_object(
                'id', q.id,
                'question', q.question,
                'type', q.type,
                'options', (
                    SELECT jsonb_agg(jsonb_build_object(
                        'id', qo.id,
                        'content', qo.content,
                        'isCorrect', qo.is_correct
                    ))
                    FROM question_options qo
                    WHERE qo.question_id = q.id
                )
            )
            FROM question_sections qs
            JOIN questions q ON q.id = qs.question_id
            WHERE qs.section_id = s.id
        )
    END as content
FROM sections s
WHERE s.id = $1::int
`

func (q *Queries) GetSectionContent(ctx context.Context, sectionID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getSectionContent, sectionID)
	var content interface{}
	err := row.Scan(&content)
	return content, err
}

const getTextSection = `-- name: GetTextSection :one
SELECT text_content
FROM text_sections
WHERE section_id = $1::int
`

func (q *Queries) GetTextSection(ctx context.Context, sectionID int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getTextSection, sectionID)
	var text_content string
	err := row.Scan(&text_content)
	return text_content, err
}

const getTextSectionContent = `-- name: GetTextSectionContent :one
SELECT text_content
FROM text_sections
WHERE section_id = $1::int
`

func (q *Queries) GetTextSectionContent(ctx context.Context, sectionID int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getTextSectionContent, sectionID)
	var text_content string
	err := row.Scan(&text_content)
	return text_content, err
}

const getUnitModules = `-- name: GetUnitModules :many
SELECT
    id,
    created_at,
    updated_at,
    module_number,
    unit_id,
    name,
    description
FROM modules
WHERE
    unit_id = $1::int
ORDER BY module_number
`

func (q *Queries) GetUnitModules(ctx context.Context, unitID int32) ([]Module, error) {
	rows, err := q.db.QueryContext(ctx, getUnitModules, unitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Module{}
	for rows.Next() {
		var i Module
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ModuleNumber,
			&i.UnitID,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCourseProgress = `-- name: GetUserCourseProgress :one
SELECT
    current_unit_id,
    current_module_id
FROM user_courses
WHERE
    user_id = $1::int
    AND course_id = $2::int
`

type GetUserCourseProgressParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

type GetUserCourseProgressRow struct {
	CurrentUnitID   sql.NullInt32 `json:"currentUnitId"`
	CurrentModuleID sql.NullInt32 `json:"currentModuleId"`
}

func (q *Queries) GetUserCourseProgress(ctx context.Context, arg GetUserCourseProgressParams) (GetUserCourseProgressRow, error) {
	row := q.db.QueryRowContext(ctx, getUserCourseProgress, arg.UserID, arg.CourseID)
	var i GetUserCourseProgressRow
	err := row.Scan(&i.CurrentUnitID, &i.CurrentModuleID)
	return i, err
}

const getUserQuestionAnswer = `-- name: GetUserQuestionAnswer :one
SELECT uqa.option_id, uqa.answered_at, uqa.is_correct
FROM
    user_question_answers uqa
    JOIN user_module_progress ump ON ump.id = uqa.user_module_progress_id
WHERE
    ump.user_id = $1::int
    AND uqa.question_id = $2::int
`

type GetUserQuestionAnswerParams struct {
	UserID     int32 `json:"userId"`
	QuestionID int32 `json:"questionId"`
}

type GetUserQuestionAnswerRow struct {
	OptionID   int32     `json:"optionId"`
	AnsweredAt time.Time `json:"answeredAt"`
	IsCorrect  bool      `json:"isCorrect"`
}

func (q *Queries) GetUserQuestionAnswer(ctx context.Context, arg GetUserQuestionAnswerParams) (GetUserQuestionAnswerRow, error) {
	row := q.db.QueryRowContext(ctx, getUserQuestionAnswer, arg.UserID, arg.QuestionID)
	var i GetUserQuestionAnswerRow
	err := row.Scan(&i.OptionID, &i.AnsweredAt, &i.IsCorrect)
	return i, err
}

const getVideoSection = `-- name: GetVideoSection :one
SELECT 
    url as url
FROM video_sections
WHERE section_id = $1::int
`

func (q *Queries) GetVideoSection(ctx context.Context, sectionID int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getVideoSection, sectionID)
	var url string
	err := row.Scan(&url)
	return url, err
}

const getVideoSectionContent = `-- name: GetVideoSectionContent :one
SELECT url FROM video_sections WHERE section_id = $1::int
`

func (q *Queries) GetVideoSectionContent(ctx context.Context, sectionID int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getVideoSectionContent, sectionID)
	var url string
	err := row.Scan(&url)
	return url, err
}

const listCourses = `-- name: ListCourses :many
SELECT
    c.id,
    c.created_at,
    c.updated_at,
    c.name,
    c.description,
    c.requirements,
    c.what_you_learn,
    c.background_color,
    c.icon_url,
    c.duration,
    c.difficulty_level,
    c.rating,
    COUNT(*) OVER() as total_count
FROM courses c
ORDER BY c.created_at DESC
LIMIT $2::int
OFFSET $1::int
`

type ListCoursesParams struct {
	PageOffset int32 `json:"pageOffset"`
	PageLimit  int32 `json:"pageLimit"`
}

type ListCoursesRow struct {
	ID              int32               `json:"id"`
	CreatedAt       time.Time           `json:"createdAt"`
	UpdatedAt       time.Time           `json:"updatedAt"`
	Name            string              `json:"name"`
	Description     string              `json:"description"`
	Requirements    sql.NullString      `json:"requirements"`
	WhatYouLearn    sql.NullString      `json:"whatYouLearn"`
	BackgroundColor sql.NullString      `json:"backgroundColor"`
	IconUrl         sql.NullString      `json:"iconUrl"`
	Duration        sql.NullInt32       `json:"duration"`
	DifficultyLevel NullDifficultyLevel `json:"difficultyLevel"`
	Rating          sql.NullFloat64     `json:"rating"`
	TotalCount      int64               `json:"totalCount"`
}

func (q *Queries) ListCourses(ctx context.Context, arg ListCoursesParams) ([]ListCoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCourses, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCoursesRow{}
	for rows.Next() {
		var i ListCoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Requirements,
			&i.WhatYouLearn,
			&i.BackgroundColor,
			&i.IconUrl,
			&i.Duration,
			&i.DifficultyLevel,
			&i.Rating,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startCourse = `-- name: StartCourse :exec
INSERT INTO user_courses 
(user_id, course_id, current_unit_id, current_module_id)
VALUES ($1::int, $2::int, $3::int, $4::int)
RETURNING current_unit_id, current_module_id
`

type StartCourseParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
	UnitID   int32 `json:"unitId"`
	ModuleID int32 `json:"moduleId"`
}

func (q *Queries) StartCourse(ctx context.Context, arg StartCourseParams) error {
	_, err := q.db.ExecContext(ctx, startCourse,
		arg.UserID,
		arg.CourseID,
		arg.UnitID,
		arg.ModuleID,
	)
	return err
}
