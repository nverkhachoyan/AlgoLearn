// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: modules.sql

package gen

import (
	"context"
	"encoding/json"
	"time"
)

const createModule = `-- name: CreateModule :one
WITH new_module AS (
    SELECT COALESCE(MAX(module_number), 0) + 1 as next_number
    FROM modules
    WHERE unit_id = $1::int
)
INSERT INTO modules (
    module_number,
    unit_id,
    name,
    description
) VALUES (
    (SELECT next_number FROM new_module),
    $1::int,
    $2::text,
    $3::text
)
RETURNING id, created_at, updated_at, module_number, unit_id, name, description
`

type CreateModuleParams struct {
	UnitID      int32  `json:"unitId"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreateModule(ctx context.Context, arg CreateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, createModule, arg.UnitID, arg.Name, arg.Description)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const deleteModule = `-- name: DeleteModule :exec
DELETE FROM modules WHERE id = $1::int
`

func (q *Queries) DeleteModule(ctx context.Context, moduleID int32) error {
	_, err := q.db.ExecContext(ctx, deleteModule, moduleID)
	return err
}

const getModuleTotalCount = `-- name: GetModuleTotalCount :one
SELECT COUNT(*) FROM modules WHERE unit_id = $1::int
`

func (q *Queries) GetModuleTotalCount(ctx context.Context, unitID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getModuleTotalCount, unitID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getModuleWithProgress = `-- name: GetModuleWithProgress :one
SELECT jsonb_build_object(
    'id', m.id,
    'createdAt', m.created_at,
    'updatedAt', m.updated_at,
    'moduleNumber', m.module_number,
    'unitId', m.unit_id,
    'name', m.name,
    'description', m.description,
    'progress', COALESCE(ump.progress, 0.0),
    'status', COALESCE(ump.status, 'uninitiated'::module_progress_status),
    'startedAt', ump.started_at,
    'completedAt', ump.completed_at,
    'lastAccessed', ump.last_accessed,
    'currentSectionId', ump.current_section_id
) as module
FROM modules m
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
WHERE m.unit_id = $2::int AND m.id = $3::int
`

type GetModuleWithProgressParams struct {
	UserID   int32 `json:"userId"`
	UnitID   int32 `json:"unitId"`
	ModuleID int32 `json:"moduleId"`
}

func (q *Queries) GetModuleWithProgress(ctx context.Context, arg GetModuleWithProgressParams) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getModuleWithProgress, arg.UserID, arg.UnitID, arg.ModuleID)
	var module json.RawMessage
	err := row.Scan(&module)
	return module, err
}

const getModulesList = `-- name: GetModulesList :many
SELECT 
    m.id, m.created_at, m.updated_at, m.module_number, m.unit_id, m.name, m.description,
    jsonb_build_object(
        'progress', COALESCE(ump.progress, 0.0),
        'status', COALESCE(ump.status, 'uninitiated'::module_progress_status),
        'startedAt', ump.started_at,
        'completedAt', ump.completed_at,
        'lastAccessed', ump.last_accessed,
        'currentSectionId', ump.current_section_id
    )::json as module_progress
FROM modules m
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
WHERE m.unit_id = $2::int
ORDER BY m.module_number
LIMIT $4::int
OFFSET $3::int
`

type GetModulesListParams struct {
	UserID     int32 `json:"userId"`
	UnitID     int32 `json:"unitId"`
	PageOffset int32 `json:"pageOffset"`
	PageSize   int32 `json:"pageSize"`
}

type GetModulesListRow struct {
	ID             int32           `json:"id"`
	CreatedAt      time.Time       `json:"createdAt"`
	UpdatedAt      time.Time       `json:"updatedAt"`
	ModuleNumber   int32           `json:"moduleNumber"`
	UnitID         int32           `json:"unitId"`
	Name           string          `json:"name"`
	Description    string          `json:"description"`
	ModuleProgress json.RawMessage `json:"moduleProgress"`
}

func (q *Queries) GetModulesList(ctx context.Context, arg GetModulesListParams) ([]GetModulesListRow, error) {
	rows, err := q.db.QueryContext(ctx, getModulesList,
		arg.UserID,
		arg.UnitID,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModulesListRow{}
	for rows.Next() {
		var i GetModulesListRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ModuleNumber,
			&i.UnitID,
			&i.Name,
			&i.Description,
			&i.ModuleProgress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextModuleId = `-- name: GetNextModuleId :one
SELECT id
FROM modules 
WHERE unit_id = $1::int 
  AND module_number > $2::int 
ORDER BY module_number ASC 
LIMIT 1
`

type GetNextModuleIdParams struct {
	UnitID       int32 `json:"unitId"`
	ModuleNumber int32 `json:"moduleNumber"`
}

func (q *Queries) GetNextModuleId(ctx context.Context, arg GetNextModuleIdParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextModuleId, arg.UnitID, arg.ModuleNumber)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getSectionProgress = `-- name: GetSectionProgress :many
SELECT 
    section_id,
    jsonb_build_object(
        'sectionId', section_id,
        'seenAt', seen_at,
        'hasSeen', has_seen,
        'startedAt', started_at,
        'completedAt', completed_at,
        'progress', progress
    ) as progress
FROM user_section_progress
WHERE user_id = $1::int AND module_id = $2::int
`

type GetSectionProgressParams struct {
	UserID   int32 `json:"userId"`
	ModuleID int32 `json:"moduleId"`
}

type GetSectionProgressRow struct {
	SectionID int32           `json:"sectionId"`
	Progress  json.RawMessage `json:"progress"`
}

func (q *Queries) GetSectionProgress(ctx context.Context, arg GetSectionProgressParams) ([]GetSectionProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionProgress, arg.UserID, arg.ModuleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSectionProgressRow{}
	for rows.Next() {
		var i GetSectionProgressRow
		if err := rows.Scan(&i.SectionID, &i.Progress); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleModuleSections = `-- name: GetSingleModuleSections :many
WITH section_content AS (
    SELECT 
        s.id as section_id,
        s.type,
        CASE s.type
            WHEN 'text' THEN (
                SELECT jsonb_build_object('text', text_content)
                FROM text_sections ts
                WHERE ts.section_id = s.id
            )
            WHEN 'video' THEN (
                SELECT jsonb_build_object('url', url)
                FROM video_sections vs
                WHERE vs.section_id = s.id
            )
            WHEN 'question' THEN (
                SELECT jsonb_build_object(
                    'id', q.id,
                    'question', q.question,
                    'type', q.type,
                    'options', COALESCE(
                        (SELECT jsonb_agg(
                            jsonb_build_object(
                                'id', qo.id,
                                'content', qo.content,
                                'isCorrect', qo.is_correct
                            ) ORDER BY qo.id
                        )
                        FROM question_options qo
                        WHERE qo.question_id = q.id
                        ), '[]'::jsonb),
                    'userQuestionAnswer', (
                        SELECT CASE 
                            WHEN uqa.id IS NOT NULL THEN
                                jsonb_build_object(
                                    'optionId', uqa.option_id,
                                    'answeredAt', uqa.answered_at,
                                    'isCorrect', uqa.is_correct,
                                    'progress', uqa.progress
                                )
                            ELSE NULL
                        END
                        FROM question_sections qs2
                        LEFT JOIN user_module_progress ump ON ump.module_id = $1::int AND ump.user_id = $2::int
                        LEFT JOIN user_question_answers uqa ON uqa.user_module_progress_id = ump.id 
                            AND uqa.question_id = qs2.question_id
                        WHERE qs2.section_id = s.id
                    )
                )
                FROM question_sections qs
                JOIN questions q ON q.id = qs.question_id
                WHERE qs.section_id = s.id
            )
        END as content
    FROM sections s
    WHERE s.module_id = $1::int
)
SELECT 
    s.id,
    s.created_at,
    s.updated_at,
    s.type,
    s.position,
    COALESCE(sc.content, '{}'::jsonb)::json as content
FROM sections s
LEFT JOIN section_content sc ON sc.section_id = s.id
WHERE s.module_id = $1::int
ORDER BY s.position
`

type GetSingleModuleSectionsParams struct {
	ModuleID int32 `json:"moduleId"`
	UserID   int32 `json:"userId"`
}

type GetSingleModuleSectionsRow struct {
	ID        int32           `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	Type      string          `json:"type"`
	Position  int32           `json:"position"`
	Content   json.RawMessage `json:"content"`
}

func (q *Queries) GetSingleModuleSections(ctx context.Context, arg GetSingleModuleSectionsParams) ([]GetSingleModuleSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSingleModuleSections, arg.ModuleID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSingleModuleSectionsRow{}
	for rows.Next() {
		var i GetSingleModuleSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Position,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveModuleProgress = `-- name: SaveModuleProgress :exec
SELECT save_module_progress($1::int, $2::int, $3::jsonb, $4::jsonb)
`

type SaveModuleProgressParams struct {
	UserID    int32           `json:"userId"`
	ModuleID  int32           `json:"moduleId"`
	Sections  json.RawMessage `json:"sections"`
	Questions json.RawMessage `json:"questions"`
}

func (q *Queries) SaveModuleProgress(ctx context.Context, arg SaveModuleProgressParams) error {
	_, err := q.db.ExecContext(ctx, saveModuleProgress,
		arg.UserID,
		arg.ModuleID,
		arg.Sections,
		arg.Questions,
	)
	return err
}

const updateModule = `-- name: UpdateModule :one
UPDATE modules
SET
    name = COALESCE(NULLIF($1::text, ''), name),
    description = COALESCE(NULLIF($2::text, ''), description),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3::int
RETURNING id, created_at, updated_at, module_number, unit_id, name, description
`

type UpdateModuleParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ModuleID    int32  `json:"moduleId"`
}

func (q *Queries) UpdateModule(ctx context.Context, arg UpdateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, updateModule, arg.Name, arg.Description, arg.ModuleID)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}
