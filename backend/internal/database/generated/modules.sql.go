// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: modules.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const calculateCourseProgress = `-- name: CalculateCourseProgress :one
SELECT
    CASE
        WHEN COUNT(*) = 0 THEN 0::float
        ELSE (
            COUNT(CASE WHEN ump.status = 'completed' THEN 1 END)::FLOAT /
            COUNT(*)::FLOAT
        ) * 100
    END as progress
FROM modules m
JOIN units u ON m.unit_id = u.id
LEFT JOIN user_module_progress ump
    ON ump.module_id = m.id
    AND ump.user_id = $1
WHERE u.course_id = $2
`

type CalculateCourseProgressParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

func (q *Queries) CalculateCourseProgress(ctx context.Context, arg CalculateCourseProgressParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, calculateCourseProgress, arg.UserID, arg.CourseID)
	var progress interface{}
	err := row.Scan(&progress)
	return progress, err
}

const calculateModuleProgress = `-- name: CalculateModuleProgress :one
SELECT
    CASE
        WHEN COUNT(*) = 0 THEN 0::float
        ELSE (
            COUNT(CASE
                WHEN s.type = 'question' THEN
                    CASE WHEN uqa.is_correct THEN 1 END
                ELSE
                    CASE WHEN usp.has_seen THEN 1 END
            END)::FLOAT / COUNT(*)::FLOAT
        ) * 100
    END as progress
FROM sections s
LEFT JOIN user_section_progress usp
    ON usp.section_id = s.id
    AND usp.user_id = $1
LEFT JOIN question_sections qs
    ON s.id = qs.section_id
LEFT JOIN user_question_answers uqa
    ON qs.question_id = uqa.question_id
    AND uqa.user_module_progress_id = $2
WHERE s.module_id = $3
`

type CalculateModuleProgressParams struct {
	UserID               int32 `json:"userId"`
	UserModuleProgressID int32 `json:"userModuleProgressId"`
	ModuleID             int32 `json:"moduleId"`
}

func (q *Queries) CalculateModuleProgress(ctx context.Context, arg CalculateModuleProgressParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, calculateModuleProgress, arg.UserID, arg.UserModuleProgressID, arg.ModuleID)
	var progress interface{}
	err := row.Scan(&progress)
	return progress, err
}

const createModule = `-- name: CreateModule :one
WITH new_module AS (
    SELECT COALESCE(MAX(module_number), 0) + 1 as next_number
    FROM modules
    WHERE unit_id = $1::int
)
INSERT INTO modules (
    module_number,
    unit_id,
    name,
    description
) VALUES (
    (SELECT next_number FROM new_module),
    $1::int,
    $2::text,
    $3::text
)
RETURNING id, created_at, updated_at, module_number, unit_id, name, description
`

type CreateModuleParams struct {
	UnitID      int32  `json:"unitId"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreateModule(ctx context.Context, arg CreateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, createModule, arg.UnitID, arg.Name, arg.Description)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const deleteModule = `-- name: DeleteModule :exec
DELETE FROM modules WHERE id = $1::int
`

func (q *Queries) DeleteModule(ctx context.Context, moduleID int32) error {
	_, err := q.db.ExecContext(ctx, deleteModule, moduleID)
	return err
}

const getCourseAndUnitIDs = `-- name: GetCourseAndUnitIDs :one
SELECT u.course_id, m.unit_id
FROM modules m
    JOIN units u ON m.unit_id = u.id
WHERE
    m.id = $1
`

type GetCourseAndUnitIDsRow struct {
	CourseID int32 `json:"courseId"`
	UnitID   int32 `json:"unitId"`
}

func (q *Queries) GetCourseAndUnitIDs(ctx context.Context, id int32) (GetCourseAndUnitIDsRow, error) {
	row := q.db.QueryRowContext(ctx, getCourseAndUnitIDs, id)
	var i GetCourseAndUnitIDsRow
	err := row.Scan(&i.CourseID, &i.UnitID)
	return i, err
}

const getCurrentUnitAndModule = `-- name: GetCurrentUnitAndModule :one
WITH latest_module_progress AS (
    SELECT 
        ump.module_id,
        ump.updated_at
    FROM user_module_progress ump
    JOIN modules m ON m.id = ump.module_id
    JOIN units u ON u.id = m.unit_id
    WHERE ump.user_id = $1 
    AND u.course_id = $2
    ORDER BY ump.updated_at DESC NULLS LAST
    LIMIT 1
)
SELECT
    u.id as unit_id,
    u.created_at as unit_created_at,
    u.updated_at as unit_updated_at,
    u.name as unit_name,
    u.description as unit_description,
    u.unit_number as unit_number,
    m.id as module_id,
    m.created_at as module_created_at,
    m.updated_at as module_updated_at,
    m.name as module_name,
    m.description as module_description,
    m.module_number as module_number,
    COALESCE(ump.progress, 0) as module_progress,
    COALESCE(ump.status, 'uninitiated'::module_progress_status) as module_status
FROM latest_module_progress lmp
JOIN modules m ON m.id = lmp.module_id
JOIN units u ON u.id = m.unit_id
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1
`

type GetCurrentUnitAndModuleParams struct {
	UserID   int32 `json:"userId"`
	CourseID int32 `json:"courseId"`
}

type GetCurrentUnitAndModuleRow struct {
	UnitID            int32                `json:"unitId"`
	UnitCreatedAt     time.Time            `json:"unitCreatedAt"`
	UnitUpdatedAt     time.Time            `json:"unitUpdatedAt"`
	UnitName          string               `json:"unitName"`
	UnitDescription   string               `json:"unitDescription"`
	UnitNumber        int32                `json:"unitNumber"`
	ModuleID          int32                `json:"moduleId"`
	ModuleCreatedAt   time.Time            `json:"moduleCreatedAt"`
	ModuleUpdatedAt   time.Time            `json:"moduleUpdatedAt"`
	ModuleName        string               `json:"moduleName"`
	ModuleDescription string               `json:"moduleDescription"`
	ModuleNumber      int32                `json:"moduleNumber"`
	ModuleProgress    float64              `json:"moduleProgress"`
	ModuleStatus      ModuleProgressStatus `json:"moduleStatus"`
}

func (q *Queries) GetCurrentUnitAndModule(ctx context.Context, arg GetCurrentUnitAndModuleParams) (GetCurrentUnitAndModuleRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentUnitAndModule, arg.UserID, arg.CourseID)
	var i GetCurrentUnitAndModuleRow
	err := row.Scan(
		&i.UnitID,
		&i.UnitCreatedAt,
		&i.UnitUpdatedAt,
		&i.UnitName,
		&i.UnitDescription,
		&i.UnitNumber,
		&i.ModuleID,
		&i.ModuleCreatedAt,
		&i.ModuleUpdatedAt,
		&i.ModuleName,
		&i.ModuleDescription,
		&i.ModuleNumber,
		&i.ModuleProgress,
		&i.ModuleStatus,
	)
	return i, err
}

const getLastModuleNumber = `-- name: GetLastModuleNumber :one
SELECT COALESCE(MAX(module_number), 0) as last_number
FROM modules
WHERE
    unit_id = $1::int
`

func (q *Queries) GetLastModuleNumber(ctx context.Context, unitID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLastModuleNumber, unitID)
	var last_number interface{}
	err := row.Scan(&last_number)
	return last_number, err
}

const getModuleTotalCount = `-- name: GetModuleTotalCount :one
SELECT COUNT(*) FROM modules WHERE unit_id = $1::int
`

func (q *Queries) GetModuleTotalCount(ctx context.Context, unitID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getModuleTotalCount, unitID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getModuleWithProgress = `-- name: GetModuleWithProgress :one
SELECT jsonb_build_object(
    'id', m.id,
    'createdAt', m.created_at,
    'updatedAt', m.updated_at,
    'moduleNumber', m.module_number,
    'unitId', m.unit_id,
    'name', m.name,
    'description', m.description,
    'progress', COALESCE(ump.progress, 0.0),
    'status', COALESCE(ump.status, 'uninitiated'::module_progress_status),
    'startedAt', ump.started_at,
    'completedAt', ump.completed_at,
    'lastAccessed', ump.last_accessed
) as module
FROM modules m
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
WHERE m.unit_id = $2::int AND m.id = $3::int
`

type GetModuleWithProgressParams struct {
	UserID   int32 `json:"userId"`
	UnitID   int32 `json:"unitId"`
	ModuleID int32 `json:"moduleId"`
}

func (q *Queries) GetModuleWithProgress(ctx context.Context, arg GetModuleWithProgressParams) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getModuleWithProgress, arg.UserID, arg.UnitID, arg.ModuleID)
	var module json.RawMessage
	err := row.Scan(&module)
	return module, err
}

const getModulesList = `-- name: GetModulesList :many
SELECT 
    m.id, m.created_at, m.updated_at, m.module_number, m.unit_id, m.name, m.description,
    jsonb_build_object(
        'progress', COALESCE(ump.progress, 0.0),
        'status', COALESCE(ump.status, 'uninitiated'::module_progress_status),
        'startedAt', ump.started_at,
        'completedAt', ump.completed_at,
        'lastAccessed', ump.last_accessed,
        'currentSectionId', ump.current_section_id
    )::json as module_progress
FROM modules m
LEFT JOIN user_module_progress ump ON ump.module_id = m.id AND ump.user_id = $1::int
WHERE m.unit_id = $2::int
ORDER BY m.module_number
LIMIT $4::int
OFFSET $3::int
`

type GetModulesListParams struct {
	UserID     int32 `json:"userId"`
	UnitID     int32 `json:"unitId"`
	PageOffset int32 `json:"pageOffset"`
	PageSize   int32 `json:"pageSize"`
}

type GetModulesListRow struct {
	ID             int32           `json:"id"`
	CreatedAt      time.Time       `json:"createdAt"`
	UpdatedAt      time.Time       `json:"updatedAt"`
	ModuleNumber   int32           `json:"moduleNumber"`
	UnitID         int32           `json:"unitId"`
	Name           string          `json:"name"`
	Description    string          `json:"description"`
	ModuleProgress json.RawMessage `json:"moduleProgress"`
}

func (q *Queries) GetModulesList(ctx context.Context, arg GetModulesListParams) ([]GetModulesListRow, error) {
	rows, err := q.db.QueryContext(ctx, getModulesList,
		arg.UserID,
		arg.UnitID,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModulesListRow{}
	for rows.Next() {
		var i GetModulesListRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ModuleNumber,
			&i.UnitID,
			&i.Name,
			&i.Description,
			&i.ModuleProgress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextModuleId = `-- name: GetNextModuleId :one
SELECT id
FROM modules 
WHERE unit_id = $1::int 
  AND module_number > $2::int 
ORDER BY module_number ASC 
LIMIT 1
`

type GetNextModuleIdParams struct {
	UnitID       int32 `json:"unitId"`
	ModuleNumber int32 `json:"moduleNumber"`
}

func (q *Queries) GetNextModuleId(ctx context.Context, arg GetNextModuleIdParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextModuleId, arg.UnitID, arg.ModuleNumber)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getSectionProgress = `-- name: GetSectionProgress :many
SELECT 
    section_id,
    jsonb_build_object(
        'sectionId', section_id,
        'seenAt', seen_at,
        'hasSeen', has_seen,
        'startedAt', started_at,
        'completedAt', completed_at,
        'progress', progress
    ) as progress
FROM user_section_progress
WHERE user_id = $1::int AND module_id = $2::int
`

type GetSectionProgressParams struct {
	UserID   int32 `json:"userId"`
	ModuleID int32 `json:"moduleId"`
}

type GetSectionProgressRow struct {
	SectionID int32           `json:"sectionId"`
	Progress  json.RawMessage `json:"progress"`
}

func (q *Queries) GetSectionProgress(ctx context.Context, arg GetSectionProgressParams) ([]GetSectionProgressRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionProgress, arg.UserID, arg.ModuleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSectionProgressRow{}
	for rows.Next() {
		var i GetSectionProgressRow
		if err := rows.Scan(&i.SectionID, &i.Progress); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleModuleSections = `-- name: GetSingleModuleSections :many
WITH section_content AS (
    SELECT 
        s.id as section_id,
        s.type,
        CASE s.type
            WHEN 'text' THEN (
                SELECT jsonb_build_object('text', text_content)
                FROM text_sections ts
                WHERE ts.section_id = s.id
            )
            WHEN 'markdown' THEN (
                SELECT jsonb_build_object('markdown', markdown)
                FROM markdown_sections ms
                WHERE ms.section_id = s.id
            )
            WHEN 'video' THEN (
                SELECT jsonb_build_object('url', url)
                FROM video_sections vs
                WHERE vs.section_id = s.id
            )
            WHEN 'question' THEN (
                SELECT jsonb_build_object(
                    'id', q.id,
                    'question', q.question,
                    'type', q.type,
                    'options', COALESCE(
                        (SELECT jsonb_agg(
                            jsonb_build_object(
                                'id', qo.id,
                                'content', qo.content,
                                'isCorrect', qo.is_correct
                            ) ORDER BY qo.id
                        )
                        FROM question_options qo
                        WHERE qo.question_id = q.id
                        ), '[]'::jsonb),
                    'userQuestionAnswer', (
                        SELECT CASE 
                            WHEN uqa.id IS NOT NULL THEN
                                jsonb_build_object(
                                    'optionId', uqa.option_id,
                                    'answeredAt', uqa.answered_at,
                                    'isCorrect', uqa.is_correct,
                                    'progress', uqa.progress
                                )
                            ELSE NULL
                        END
                        FROM question_sections qs2
                        LEFT JOIN user_module_progress ump ON ump.module_id = $1::int AND ump.user_id = $2::int
                        LEFT JOIN user_question_answers uqa ON uqa.user_module_progress_id = ump.id 
                            AND uqa.question_id = q.id
                        WHERE qs2.section_id = s.id
                        LIMIT 1
                    )
                )
                FROM question_sections qs
                JOIN questions q ON q.id = qs.question_id
                WHERE qs.section_id = s.id
            )
        END as content
    FROM sections s
    WHERE s.module_id = $1::int
)
SELECT 
    s.id,
    s.created_at,
    s.updated_at,
    s.type,
    s.position,
    COALESCE(sc.content, '{}'::jsonb)::json as content
FROM sections s
LEFT JOIN section_content sc ON sc.section_id = s.id
WHERE s.module_id = $1::int
ORDER BY s.position
`

type GetSingleModuleSectionsParams struct {
	ModuleID int32 `json:"moduleId"`
	UserID   int32 `json:"userId"`
}

type GetSingleModuleSectionsRow struct {
	ID        int32           `json:"id"`
	CreatedAt time.Time       `json:"createdAt"`
	UpdatedAt time.Time       `json:"updatedAt"`
	Type      string          `json:"type"`
	Position  int32           `json:"position"`
	Content   json.RawMessage `json:"content"`
}

func (q *Queries) GetSingleModuleSections(ctx context.Context, arg GetSingleModuleSectionsParams) ([]GetSingleModuleSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSingleModuleSections, arg.ModuleID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSingleModuleSectionsRow{}
	for rows.Next() {
		var i GetSingleModuleSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.Position,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertModule = `-- name: InsertModule :one
INSERT INTO
    modules (
        module_number,
        unit_id,
        name,
        description
    )
VALUES ($1, $2, $3, $4) RETURNING id, created_at, updated_at, module_number, unit_id, name, description
`

type InsertModuleParams struct {
	ModuleNumber int32  `json:"moduleNumber"`
	UnitID       int32  `json:"unitId"`
	Name         string `json:"name"`
	Description  string `json:"description"`
}

func (q *Queries) InsertModule(ctx context.Context, arg InsertModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, insertModule,
		arg.ModuleNumber,
		arg.UnitID,
		arg.Name,
		arg.Description,
	)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const insertQuestion = `-- name: InsertQuestion :one
INSERT INTO
    questions (
        type,
        question,
        difficulty_level
    )
VALUES ($1, $2, $3) RETURNING id, created_at, updated_at, type, question, difficulty_level
`

type InsertQuestionParams struct {
	Type            string              `json:"type"`
	Question        string              `json:"question"`
	DifficultyLevel NullDifficultyLevel `json:"difficultyLevel"`
}

func (q *Queries) InsertQuestion(ctx context.Context, arg InsertQuestionParams) (Question, error) {
	row := q.db.QueryRowContext(ctx, insertQuestion, arg.Type, arg.Question, arg.DifficultyLevel)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.Question,
		&i.DifficultyLevel,
	)
	return i, err
}

const insertQuestionOption = `-- name: InsertQuestionOption :exec
INSERT INTO
    question_options (
        question_id,
        content,
        is_correct
    )
VALUES ($1, $2, $3)
`

type InsertQuestionOptionParams struct {
	QuestionID int32  `json:"questionId"`
	Content    string `json:"content"`
	IsCorrect  bool   `json:"isCorrect"`
}

func (q *Queries) InsertQuestionOption(ctx context.Context, arg InsertQuestionOptionParams) error {
	_, err := q.db.ExecContext(ctx, insertQuestionOption, arg.QuestionID, arg.Content, arg.IsCorrect)
	return err
}

const insertQuestionSection = `-- name: InsertQuestionSection :exec
INSERT INTO
    question_sections (section_id, question_id)
VALUES ($1, $2)
`

type InsertQuestionSectionParams struct {
	SectionID  int32 `json:"sectionId"`
	QuestionID int32 `json:"questionId"`
}

func (q *Queries) InsertQuestionSection(ctx context.Context, arg InsertQuestionSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertQuestionSection, arg.SectionID, arg.QuestionID)
	return err
}

const insertQuestionTag = `-- name: InsertQuestionTag :exec
INSERT INTO question_tags (question_id, tag_id) VALUES ($1, $2)
`

type InsertQuestionTagParams struct {
	QuestionID int32 `json:"questionId"`
	TagID      int32 `json:"tagId"`
}

func (q *Queries) InsertQuestionTag(ctx context.Context, arg InsertQuestionTagParams) error {
	_, err := q.db.ExecContext(ctx, insertQuestionTag, arg.QuestionID, arg.TagID)
	return err
}

const insertSection = `-- name: InsertSection :one
INSERT INTO
    sections (module_id, type, position)
VALUES ($1, $2, $3) RETURNING id, created_at, updated_at, module_id, type, position
`

type InsertSectionParams struct {
	ModuleID int32  `json:"moduleId"`
	Type     string `json:"type"`
	Position int32  `json:"position"`
}

func (q *Queries) InsertSection(ctx context.Context, arg InsertSectionParams) (Section, error) {
	row := q.db.QueryRowContext(ctx, insertSection, arg.ModuleID, arg.Type, arg.Position)
	var i Section
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ModuleID,
		&i.Type,
		&i.Position,
	)
	return i, err
}

const insertTag = `-- name: InsertTag :one
INSERT INTO
    tags (name)
VALUES ($1) ON CONFLICT (name) DO
UPDATE
SET
    name = EXCLUDED.name RETURNING id
`

func (q *Queries) InsertTag(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertTag, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertTextSection = `-- name: InsertTextSection :exec
INSERT INTO
    text_sections (section_id, text_content)
VALUES ($1, $2)
`

type InsertTextSectionParams struct {
	SectionID   int32  `json:"sectionId"`
	TextContent string `json:"textContent"`
}

func (q *Queries) InsertTextSection(ctx context.Context, arg InsertTextSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertTextSection, arg.SectionID, arg.TextContent)
	return err
}

const insertVideoSection = `-- name: InsertVideoSection :exec
INSERT INTO video_sections (section_id, url) VALUES ($1, $2)
`

type InsertVideoSectionParams struct {
	SectionID int32  `json:"sectionId"`
	Url       string `json:"url"`
}

func (q *Queries) InsertVideoSection(ctx context.Context, arg InsertVideoSectionParams) error {
	_, err := q.db.ExecContext(ctx, insertVideoSection, arg.SectionID, arg.Url)
	return err
}

const updateModule = `-- name: UpdateModule :one
UPDATE modules
SET
    name = COALESCE(NULLIF($1::text, ''), name),
    description = COALESCE(NULLIF($2::text, ''), description),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3::int
RETURNING id, created_at, updated_at, module_number, unit_id, name, description
`

type UpdateModuleParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ModuleID    int32  `json:"moduleId"`
}

func (q *Queries) UpdateModule(ctx context.Context, arg UpdateModuleParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, updateModule, arg.Name, arg.Description, arg.ModuleID)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ModuleNumber,
		&i.UnitID,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const upsertQuestionAnswer = `-- name: UpsertQuestionAnswer :exec
INSERT INTO
    user_question_answers (
        user_module_progress_id,
        question_id,
        option_id,
        is_correct,
        answered_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        COALESCE($5, NOW())
    ) ON CONFLICT (
        user_module_progress_id,
        question_id
    ) DO
UPDATE
SET
    option_id = EXCLUDED.option_id,
    is_correct = EXCLUDED.is_correct,
    answered_at = EXCLUDED.answered_at,
    updated_at = NOW()
`

type UpsertQuestionAnswerParams struct {
	UserModuleProgressID int32       `json:"userModuleProgressId"`
	QuestionID           int32       `json:"questionId"`
	OptionID             int32       `json:"optionId"`
	IsCorrect            bool        `json:"isCorrect"`
	Column5              interface{} `json:"column5"`
}

func (q *Queries) UpsertQuestionAnswer(ctx context.Context, arg UpsertQuestionAnswerParams) error {
	_, err := q.db.ExecContext(ctx, upsertQuestionAnswer,
		arg.UserModuleProgressID,
		arg.QuestionID,
		arg.OptionID,
		arg.IsCorrect,
		arg.Column5,
	)
	return err
}

const upsertSectionProgress = `-- name: UpsertSectionProgress :exec
INSERT INTO
    user_section_progress (
        user_id,
        module_id,
        section_id,
        has_seen,
        seen_at
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (user_id, section_id) DO
UPDATE
SET
    has_seen = EXCLUDED.has_seen,
    seen_at = EXCLUDED.seen_at
`

type UpsertSectionProgressParams struct {
	UserID    int32        `json:"userId"`
	ModuleID  int32        `json:"moduleId"`
	SectionID int32        `json:"sectionId"`
	HasSeen   bool         `json:"hasSeen"`
	SeenAt    sql.NullTime `json:"seenAt"`
}

func (q *Queries) UpsertSectionProgress(ctx context.Context, arg UpsertSectionProgressParams) error {
	_, err := q.db.ExecContext(ctx, upsertSectionProgress,
		arg.UserID,
		arg.ModuleID,
		arg.SectionID,
		arg.HasSeen,
		arg.SeenAt,
	)
	return err
}

const upsertUserCourse = `-- name: UpsertUserCourse :exec
INSERT INTO
    user_courses (user_id, course_id, progress)
VALUES ($1, $2, $3) ON CONFLICT (user_id, course_id) DO
UPDATE
SET
    progress = EXCLUDED.progress,
    updated_at = NOW()
`

type UpsertUserCourseParams struct {
	UserID   int32   `json:"userId"`
	CourseID int32   `json:"courseId"`
	Progress float64 `json:"progress"`
}

func (q *Queries) UpsertUserCourse(ctx context.Context, arg UpsertUserCourseParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserCourse, arg.UserID, arg.CourseID, arg.Progress)
	return err
}

const upsertUserModuleProgress = `-- name: UpsertUserModuleProgress :one
INSERT INTO user_module_progress (
    user_id,
    module_id,
    status,
    progress
)
VALUES (
    $1,
    $2,
    'in_progress',
    COALESCE($3, 0)
)
ON CONFLICT (user_id, module_id)
DO UPDATE SET
    progress = COALESCE($3, user_module_progress.progress),
    status = CASE
        WHEN $3 >= 100 THEN 'completed'::module_progress_status
        ELSE 'in_progress'::module_progress_status
    END,
    completed_at = CASE
        WHEN $3 >= 100 THEN NOW()
        ELSE NULL
    END,
    updated_at = NOW()
RETURNING id
`

type UpsertUserModuleProgressParams struct {
	UserID   int32       `json:"userId"`
	ModuleID int32       `json:"moduleId"`
	Column3  interface{} `json:"column3"`
}

func (q *Queries) UpsertUserModuleProgress(ctx context.Context, arg UpsertUserModuleProgressParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertUserModuleProgress, arg.UserID, arg.ModuleID, arg.Column3)
	var id int32
	err := row.Scan(&id)
	return id, err
}
